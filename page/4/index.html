<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>Page 4 | Penn&#39;s Blog</title>
  <meta name="author" content="apexpenn">
  
  <meta name="description" content="Our life is shaped by our mind; we become what we think.">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Penn&#39;s Blog"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Penn&#39;s Blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-CS_Basis_TEE" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-02-13T00:58:39.019Z"><a href="/2025/02/13/CS_Basis_TEE/">2025-02-13</a></time>
      
      
  
    <h1 class="title"><a href="/2025/02/13/CS_Basis_TEE/"></a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Trusted Execution Environments (TEEs) are CPU-encrypted isolated private enclaves inside the memory, used for protecting data in use at the hardware level.</p>
<p>While the sensitive data is inside an enclave, unauthorized entities cannot remove it, modify it, or add more data to it. The contents of an enclave remain invisible and inaccessible to external parties, protected against outsider and insider threats.</p>
<p>As a result, a TEE ensures the following:</p>
<ul>
<li>Data integrity</li>
<li>Code integrity</li>
<li>Data confidentiality</li>
</ul>
<h1 id="TEE-terminology-and-operation"><a href="#TEE-terminology-and-operation" class="headerlink" title="TEE terminology and operation"></a>TEE terminology and operation</h1><p>In a system with a TEE, we have untrusted applications running on a Rich Execution Environment (REE) and trusted applications (TAs) running on a Trusted Execution Environment (TEE).</p>
<p>Only trusted applications running on a TEE (Secure World) have complete access to the main processor, peripherals and memory, while hardware isolation protects these from untrusted applications running on the main operating system (Non-Secure World).</p>
<h1 id="How-to-implement-a-TEE"><a href="#How-to-implement-a-TEE" class="headerlink" title="How to implement a TEE?"></a>How to implement a TEE?</h1><p>We could isolate applications in a “sandbox”, for example using containers. This would prevent an application from seeing and accessing data from other applications.</p>
<p>But what about the kernel? How to prevent a code running in kernel space from being exploited to access a certain peripheral or memory region used by a trusted application?</p>
<p>Software can’t protect software!</p>
<p>So we need support in the hardware to implement a TEE. We need a way to partition and isolate the hardware (busses, peripherals, memory regions, interrupts, etc) so that the running code does not have access to protected resources.</p>
<p>That’s where ARM’s TrustZone, RISC-V’s MultiZone and many other solutions come in.</p>
<p>Hardware support to implement a TEE:</p>
<ul>
<li>ARM’s TrustZone</li>
<li>RISC-V’s MultiZone</li>
<li>AMD Platform Security Processor (PSP)</li>
<li>Intel Software Guard Extensions (SGX)</li>
<li>Apple SEP (Secure Enclave Processor)</li>
<li>Google Titan M</li>
</ul>
<h2 id="ARM’s-TrustZone"><a href="#ARM’s-TrustZone" class="headerlink" title="ARM’s TrustZone"></a>ARM’s TrustZone</h2><p>Several commercial TEE implementations have been developed over the years:</p>
<ul>
<li>Trustonic Kinibi</li>
<li>Samsung TEEGRIS</li>
<li>Qualcomm  Qualcomm Secure Execution Environment (QSEE)</li>
<li>Google Trusty(opensource)</li>
<li>OP-TEE (<a target="_blank" rel="noopener" href="https://globalplatform.org/wp-content/uploads/2018/05/Introduction-to-Trusted-Execution-Environment-15May2018.pdf">Open Portable Trusted Execution Environment</a>) (opensource)</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-CS_Basis_HSM" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-02-13T00:58:38.976Z"><a href="/2025/02/13/CS_Basis_HSM/">2025-02-13</a></time>
      
      
  
    <h1 class="title"><a href="/2025/02/13/CS_Basis_HSM/"></a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>HSM, short for Hardware Security Module, is a physical device that acts as a fortress for your data, ensuring its confidentiality, integrity, and availability. HSMs are considered as standalone and tamper-resistant hardware devices specifically engineered to fortify cryptographic processes.</p>
<p>HSMs serve the essential functions of generating, safeguarding, and managing encryption keys, which are crucial for data encryption and decryption, and creating digital signatures and code signing certificates. HSMs can take the form of plugin cards or be integrated into various hardware components, including smart cards, appliances, and external devices.</p>
<p>These devices undergo rigorous testing, validation, and certification processes, adhering to strict security standards like FIPS 140-2, Common Criteria EAL 4+, or equivalent benchmarks. These benchmarks assure users that the devices offer unparalleled levels of security and shield against potential threats, ensuring the utmost confidentiality and integrity of data.</p>
<p>According to CerteraSSL’s <a target="_blank" rel="noopener" href="https://certera.com/blog/what-is-hardware-security-module-hsm-comprehensive-guide">HSM Comprehensive Guide</a>, let’s first walk through the Key components of HSM, different types of HSM, features of HSM and then look into some detail of Vehicular Hardware Security Module</p>
<h1 id="Key-components-of-HSM"><a href="#Key-components-of-HSM" class="headerlink" title="Key components of HSM"></a>Key components of HSM</h1><h2 id="Key-Generation-and-Storage"><a href="#Key-Generation-and-Storage" class="headerlink" title="Key Generation and Storage"></a>Key Generation and Storage</h2><p>HSMs use secure random number generators (RNGs) to generate strong cryptographic keys. The generated keys are securely stored within the HSM and safeguarded against unauthorized access or extraction, ensuring keys’ integrity and randomness, which are crucial for robust cryptographic operations.</p>
<h2 id="Key-Management"><a href="#Key-Management" class="headerlink" title="Key Management"></a>Key Management</h2><p>HSMs provide a comprehensive suite of key management functionalities, which includes key generation, import, export, versioning, and facilitating key lifecycle operations like rotation and retirement.</p>
<h2 id="Cryptographic-Operations"><a href="#Cryptographic-Operations" class="headerlink" title="Cryptographic Operations"></a>Cryptographic Operations</h2><p>HSM excels in performing various cryptographic operations. They offer encryption and decryption capabilities and play a critical role in generating and verifying digital signatures, ensuring the authenticity and integrity of electronic documents and transactions. They also support secure hashing algorithms for data integrity verification and provide secure APIs and interfaces for the seamless integration of cryptographic functionalities into applications.</p>
<h2 id="Secure-APIs-and-Interfaces"><a href="#Secure-APIs-and-Interfaces" class="headerlink" title="Secure APIs and Interfaces"></a>Secure APIs and Interfaces</h2><p>HSMs offer secure APIs and interfaces. APIs establish a secure communication channel between the application and the HSM, preventing unauthorized access and safeguarding cryptographic material from tampering.</p>
<h2 id="Physical-and-Logical-Security"><a href="#Physical-and-Logical-Security" class="headerlink" title="Physical and Logical Security"></a>Physical and Logical Security</h2><p>HSMs incorporate robust physical and logical security measures. Physical security features include tamper-evident casings, sensors to detect physical attacks and secure key storage mechanisms. Logical security encompasses robust authentication mechanisms, access controls, and cryptographic operations executed within a trusted environment.</p>
<h2 id="Compliance-and-Auditing"><a href="#Compliance-and-Auditing" class="headerlink" title="Compliance and Auditing"></a>Compliance and Auditing</h2><p>HSMs provide the necessary capabilities to comply with security regulations and industry standards. They offer auditing and logging mechanisms, enabling organizations to track and monitor cryptographic operations. Compliance features within HSMs assist in demonstrating adherence to security best practices and successfully passing regulatory audits.</p>
<h1 id="Types-of-HSM"><a href="#Types-of-HSM" class="headerlink" title="Types of HSM"></a>Types of HSM</h1><p>HSM devices come in various types, each tailored to specific use cases and industry requirements. However, there are two main types of HSMs:</p>
<h2 id="General-Purpose-HSMs"><a href="#General-Purpose-HSMs" class="headerlink" title="General Purpose HSMs:"></a>General Purpose HSMs:</h2><p>General purpose HSMs are versatile devices that support a wide range of encryption algorithms, such as CNG, CAPI, and more. They are designed to cater to various applications that require cryptographic services and secure key management.</p>
<p>General purpose HSMs are commonly used in environments where Public Key Infrastructures (PKIs) are implemented and in managing crypto-wallets and other sensitive data. These HSMs offer flexibility and compatibility with different systems and encryption standards.</p>
<h2 id="Payment-and-Transaction-HSMs"><a href="#Payment-and-Transaction-HSMs" class="headerlink" title="Payment and Transaction HSMs:"></a>Payment and Transaction HSMs:</h2><p>These HSM devices are tailored to the financial industry’s requirements and are essential in maintaining compliance with Payment Card Industry Data Security Standards (PCI DSS).</p>
<p>Payment and transaction HSMs provide specialized cryptographic services and secure key management solutions that align with the specific needs of payment processing systems. They play a critical role in securing financial transactions and ensuring the confidentiality and integrity of payment card data.</p>
<p>It’s important to note that while general purpose HSMs offer broader applicability, payment and transaction HSMs focus specifically on securing payment card information and complying with industry-specific standards. The choice between these two types of HSMs depends on the specific security requirements and use cases of the organization or industry involved.</p>
<h1 id="Features-of-HSM"><a href="#Features-of-HSM" class="headerlink" title="Features of HSM"></a>Features of HSM</h1><p>HSMs offer a range of features to provide maximum security for cryptographic key management and operations. Here are some key features:</p>
<h2 id="Tamper-Resistance"><a href="#Tamper-Resistance" class="headerlink" title="Tamper Resistance:"></a>Tamper Resistance:</h2><p>HSMs are built with tamper-evident casings and physical protections. They incorporate sensors and mechanisms that detect and respond to physical tampering attempts, such as opening the casing or tampering with internal components. These features ensure the integrity of the HSM and protect against unauthorized access to cryptographic keys.</p>
<h2 id="Zeroization-of-Keys"><a href="#Zeroization-of-Keys" class="headerlink" title="Zeroization of Keys:"></a>Zeroization of Keys:</h2><p>HSMs can securely erase cryptographic keys, ensuring their complete removal from the system and preventing unauthorized access or recovery.</p>
<h2 id="Access-Controls"><a href="#Access-Controls" class="headerlink" title="Access Controls:"></a>Access Controls:</h2><p>HSMs enforce strict access controls to prevent unauthorized users from accessing sensitive cryptographic material. Role-based access control (RBAC) mechanisms ensure that only authorized individuals or applications can interact with the HSM and perform cryptographic operations.</p>
<h2 id="Robust-Authentication"><a href="#Robust-Authentication" class="headerlink" title="Robust Authentication:"></a>Robust Authentication:</h2><p>HSMs employ strong authentication mechanisms to verify the identities of users or applications attempting to access the HSM. These devices mostly employ two-factor authentication, requiring a combination of something the user knows – a password and something the user has – a smart card or something the user is – biometric data to establish trust and grant access.</p>
<h2 id="APIs-and-Interfaces"><a href="#APIs-and-Interfaces" class="headerlink" title="APIs and Interfaces:"></a>APIs and Interfaces:</h2><p>HSMs provide secure APIs and interfaces that allow applications and systems to integrate with the HSM. Standard cryptographic protocol, are often supported, enabling seamless integration with existing systems.</p>
<h2 id="Secure-Design"><a href="#Secure-Design" class="headerlink" title="Secure Design:"></a>Secure Design:</h2><p>HSMs are designed with security in mind. They undergo rigorous testing and evaluation to meet recognized security standards, such as FIPS 140-2. The design principles encompass both physical and logical security measures to create a trusted environment for cryptographic operations.</p>
<h1 id="HSM-Specification"><a href="#HSM-Specification" class="headerlink" title="HSM Specification"></a>HSM Specification</h1><h2 id="Secure-Hardware-Extension-SHE"><a href="#Secure-Hardware-Extension-SHE" class="headerlink" title="Secure Hardware Extension (SHE)"></a>Secure Hardware Extension (SHE)</h2><p>The Secure Hardware Extension (SHE) is an on-chip extension to any given microcontroller. It is intended to move the control over cryptographic keys from the software domain into the hardware domain and therefore protect those keys from software attacks. However, it is not meant to replace highly secure solutions like TPM chips or smart cards, i.e. no tamper resistance is required by the specification.</p>
<p>In 2019, AUTOSAR continues publish new technical requirements instead of SHE v1.1 as <strong>AUTOSAR_TR_SecureHardwareExtensions.pdf</strong></p>
<p>SHE is one of the earliest examples of automotive-grade connected module hardening and quickly grew to become a standard requirement by OEMs on a global basis. It was primarily built for securing cryptographic key material against software attacks, but cannot really be used to protect communications (such as V2X). As such, it has served as a basis for later HSM standards (such as EVITA). Today, modern automotive HSMs leverage functionalities from SHE, TPM and smartcards.</p>
<h3 id="SHE-Background"><a href="#SHE-Background" class="headerlink" title="SHE Background"></a>SHE Background</h3><p>The HIS consortium was founded in 2004 and consists of members from Audi, BMW, Daimler, Porsche, and Volkswagen to address activities and develop common standards related to automotive manufacturing. In 2006, HIS published a document describing the requirements for an HIS Security Module standard that incorporated mechanisms for error detection, authorization, and authenticity. This was further developed by ESCRYPT in partnership with OEMs Audi and BMW, and semiconductor vendors, such as Freescale (now NXP) into an open standard, publicly released in April 2009.</p>
<p>The resulting SHE specification outlines how a secure zone can be created within any ECU via an on-chip extension within a Microcontroller Unit (MCU), providing cryptographic services at the application layer, and isolating the storage of secret keys from the remainder of the MCU’s resources. Although the standard originated within the German automotive industry at the OEM level, it has since become an open standard accepted at the global level.</p>
<h2 id="EVITA-HSM"><a href="#EVITA-HSM" class="headerlink" title="EVITA HSM"></a>EVITA HSM</h2><p>For vehicular hardware security module, we have to konw the E-safety vehicle intrusion protected applications (<a target="_blank" rel="noopener" href="https://evita-project.org/">EVITA</a>). EVITA is a project co-funded by the European Union within the Seventh Framework Programme for research and technological development.</p>
<p>The objective of EVITA is to design, verify, and prototype an architecture for automotive on-board networks where security-relevant components are protected against tampering and sensitive data are protected against compromise.</p>
<h3 id="EVITA’s-Background"><a href="#EVITA’s-Background" class="headerlink" title="EVITA’s Background"></a>EVITA’s Background</h3><p>Future automotive safety applications based on vehicle-to-vehicle and vehicle-to-infrastructure communication have been identified as a means for decreasing the number of fatal traffic accidents. Examples of such applications are local danger warnings and electronic emergency brakes. While these functionalities inspire a new era of traffic safety, new security requirements need to be considered in order to prevent attacks on these systems. Examples of such threats are forced malfunctioning of safety-critical components or the interference with the traffic flow by means of fake messages.</p>
<h3 id="EVITA’s-Objectives"><a href="#EVITA’s-Objectives" class="headerlink" title="EVITA’s Objectives"></a>EVITA’s Objectives</h3><p>Secure and trustworthy intra-vehicular communication is the basis for trustworthy communication among cars or between cars and the infrastructure. Therefore, the objective of the EVITA project is to design, verify, and prototype an architecture for automotive on-board networks where security-relevant components are protected against tampering and sensitive data are protected against compromise when transferred inside a vehicle.</p>
<p>By focusing on the protection of the intra-vehicle communication EVITA complements other e-safety related projects that focus on the protection of the vehicle-to-X communication.</p>
<h3 id="Design-Implementation-and-Evaluation-of-a-Vehicular-Hardware-Security-Module"><a href="#Design-Implementation-and-Evaluation-of-a-Vehicular-Hardware-Security-Module" class="headerlink" title="Design, Implementation, and Evaluation of a Vehicular Hardware Security Module"></a>Design, Implementation, and Evaluation of a Vehicular Hardware Security Module</h3><p>In 2011, the 14th International Conference on Information Security and Cryptology, M. Wolf, T. Gendrullis published a paper “<a target="_blank" rel="noopener" href="https://evita-project.org/Publications/WG11.pdf">Design, implementation, and evaluation of a vehicular hardware security module</a>“, introduce the vehicular HSM officially for the first time from EVITA point of view. Based on a requirements engineering approach that incorporates all security-relevant automotive use cases and all distinctive automotive needs and constraints, EVITA presented an vehicular hardware security module (HSM) that enables a holistic protection of in-vehicle ECUs and their communications. </p>
<h3 id="Standardize-Vehicular-HSM"><a href="#Standardize-Vehicular-HSM" class="headerlink" title="Standardize Vehicular HSM"></a>Standardize Vehicular HSM</h3><p>IT systems were never designed with security in mind. But with the increasing application of digital software and various radio interfaces to the outside world (including the Internet), modern vehicles are becoming even more vulnerable to all kinds of malicious encroachments like hackers or malware. This is especially noteworthy, since in contrast to most other IT systems, a successful malicious<br>encroachment on a vehicle will not only endanger critical services or business models, but can also endanger human lives. Thus strong security measures should be mandatory when developing vehicular IT systems. Today most vehicle manufacturer (hopefully) incorporate security as a design requirement.</p>
<p>However, realizing dependable IT security solutions in a vehicular environment considerably differs from realizing IT security for typical desktop or server environments, just porting “standard” security solutions to the, moreover, very heterogeneous IT environment usually will not work. In order<br>to reliably enforce the security of software security mechanisms, the application of hardware security modules (HSM) is one effective countermeasure as HSMs:</p>
<ul>
<li>protect software security measures by acting as trusted security anchor,</li>
<li>securely generate, store, and process security-critical material shielded from any potentially malicious software,</li>
<li>restrict the possibilities of hardware tampering attacks by applying effective tamper-protection measures, </li>
<li>accelerate security measures by applying specialized cryptographic hardware,</li>
<li>reduce security costs on high volumes by applying highly optimized special circuitry instead of costly general purpose hardware.</li>
</ul>
<p>Back to the paper was published, there already exist some proprietary and singlepurpose HSM realizations used, for instance, by vehicle immobilizers, digital tachographs or tolling solutions. However, these are no general-purpose, private HSMs and hence cannot be reused by other vehicular security solutions. On the other hand, general-purpose HSMs that are currently available, for instance, the IBM 4758 cryptographic co-processor, the TCG Mobile&#x2F;Trusted Platform Module, or typical cryptographic smartcards are not applicable for use within an automotive security context. They, for instance, lack of cost efficiency, performance, physical robustness, or security functionality. Solely, the secure hardware extension (SHE) as proposed by the HIS consortium takes an exceptional position as it was explicitly designed for application in a automotive security context. However, the SHE module is mainly built for securing cryptographic key material against software attacks, but cannot be used, for instance, to protect V2X communications. </p>
<p>Security requisites (SR) and functional requisites (FR) of EVITA HSM list as follows:</p>
<ul>
<li>SR.1 Autonomous, strongly isolated security processing environment</li>
<li>SR.2 Minimal immuftable trusted code to be executed prior to ECU processor</li>
<li>SR.3 Internal non-volatile memory for storing root security artifacts</li>
<li>SR.4 Non-detachable (tamper-protected) connection with ECU hardware</li>
<li>SR.5 Authentic, confidential, fresh comm. channel between HSM and ECU</li>
<li>SR.6 Autonomously controlled alert functionality (e.g., log entry, ECU halt)</li>
<li>SR.7 Only standardized, established security algorithms (e.g., NIST1 , BSI2)</li>
</ul>
</br>

<ul>
<li>FR.1 Physical stress resistance to endure an automotive life-cycle of ≥20 years</li>
<li>FR.2 Bandwidth and latency performance that meets at least ISO 11898 [24]</li>
<li>FR.3 Compatibility with existing ECU security modules, i.e. with HIS-SHE [21]</li>
<li>FR.4 Compatibility with existing ECU microprocessor architectures</li>
<li>FR.5 Open, patent free specifications for cost-efficient OEM-wide application</li>
</ul>
<h3 id="Comparison-of-HSMs"><a href="#Comparison-of-HSMs" class="headerlink" title="Comparison of HSMs"></a>Comparison of HSMs</h3><p>This can be seen in Table 5 of “<a target="_blank" rel="noopener" href="https://evita-project.org/Publications/WG11.pdf">Design, implementation, and evaluation of a vehicular hardware security module</a>“(Page 16).</p>
<h2 id="Trusted-Platform-Module"><a href="#Trusted-Platform-Module" class="headerlink" title="Trusted Platform Module"></a>Trusted Platform Module</h2><p>Due to the massive use of x86 chips in vehicle, Trusted Platform Module (TPM) was is and will be used in E&#x2F;E architecure to protect user data.</p>
<p>Back up to the days that hackers can quickly weaponize the valuable data in laptops and computers, <a target="_blank" rel="noopener" href="https://trustedcomputinggroup.org/">Trusted Computing Group (TCG)</a> develops and prompts specification and standards of TPM to against these threat. TPM is a secure crypto-processor which is attached to a device to establish secure operations. Using a TPM helps to protect a user’s identity and sensitive data by storing the relevant keys vital for encryption, decryption and authentication. Doing so provides a first line of defense against potentially critical malware and firmware attacks, as it ensures all data remains encrypted even if an attack takes place.</p>
<h1 id="Solutions-for-virtual-environments-of-TPM"><a href="#Solutions-for-virtual-environments-of-TPM" class="headerlink" title="Solutions for virtual environments of TPM"></a>Solutions for virtual environments of TPM</h1><h2 id="vTPM"><a href="#vTPM" class="headerlink" title="vTPM"></a>vTPM</h2><p>A vTPM is a software-based representation of a traditional TPM 2.0 chip. It carries out the same hardware-based security functions a TPM, for example, attestation, key and random number generation – without the physical chip being required.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-CS_AUTOSAR_01intro" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-02-13T00:58:38.948Z"><a href="/2025/02/13/CS_AUTOSAR_01intro/">2025-02-13</a></time>
      
      
  
    <h1 class="title"><a href="/2025/02/13/CS_AUTOSAR_01intro/"></a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="BEGINNING"><a href="#BEGINNING" class="headerlink" title="BEGINNING"></a>BEGINNING</h1><p>This artical copys the introduction from <a target="_blank" rel="noopener" href="https://www.autosar.org/">AUTOSAR</a>, but a unformal reference can be used <a href="autosar.ltd">here</a>.</p>
<h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><p>AUTOSAR (AUTomotive Open System ARchitecture) is a global partnership of leading companies in the automotive and software industry to develop and establish the standardized software framework and open E&#x2F;E system architecture for intelligent mobility.</p>
<h2 id="HISTORY"><a href="#HISTORY" class="headerlink" title="HISTORY"></a>HISTORY</h2><p>Nine companies founded the AUTOSAR partnership to consolidate the expertise of partner companies in the automotive industries and define an automotive open system architecture standard to support the needs of future automotive applications</p>
<h2 id="AUTOSAR-STANDARDS-and-SPECIFICATIONS"><a href="#AUTOSAR-STANDARDS-and-SPECIFICATIONS" class="headerlink" title="AUTOSAR STANDARDS and SPECIFICATIONS"></a>AUTOSAR STANDARDS and SPECIFICATIONS</h2><p>The primary goal of the AUTOSAR development partnership is the standardization of basic system functions and functional interfaces.</p>
<h3 id="CLASSIC-PLATFORM"><a href="#CLASSIC-PLATFORM" class="headerlink" title="CLASSIC PLATFORM"></a>CLASSIC PLATFORM</h3><p>The AUTOSAR Classic Platform is a software platform with a layered software architecture defined by AUTOSAR which is used for deeply embedded systems and application software with high requirements for predictability, safety, security and responsiveness. It distinguishes at the highest level of abstraction between three software layers running on a microcontroller: Application, Runtime Environment (RTE) and Basic Software (BSW), and provides a modular and scalable approach to software development.</p>
<h3 id="ADAPTIVE-PLATFORM"><a href="#ADAPTIVE-PLATFORM" class="headerlink" title="ADAPTIVE PLATFORM"></a>ADAPTIVE PLATFORM</h3><p>The AUTOSAR Adaptive Platform implements the AUTOSAR Runtime for Adaptive Applications (ARA) and consists of functional clusters grouped into Services and the Adaptive AUTOSAR Basis. It provides two types of interfaces, Services and APIs, and is the AUTOSAR solution for high-performance ECUs to build safety-related systems. The platform is designed to meet the requirements of highly automated vehicles and supports dynamic updates and reconfigurations of software systems.</p>
<h1 id="AUTOSAR-STANDARDS"><a href="#AUTOSAR-STANDARDS" class="headerlink" title="AUTOSAR STANDARDS"></a>AUTOSAR STANDARDS</h1><p>Now, lets take a closer look at AUTOSAR <a target="_blank" rel="noopener" href="https://www.autosar.org/standards">standards</a>.</p>
<p>Autosar has 2 kinds of standards, classic platform and adaptive paltform, all contain well formart engineering documentations, these include:</p>
<ul>
<li>MOD: mode</li>
<li>MMOD: Meta Mode</li>
<li>RS: Requirement Specification</li>
<li>PRS: Protocol Requirement Specification</li>
<li>TR: Technical Report</li>
<li>SWS: Software Specification</li>
<li>EXP: Explaination</li>
<li>SRS: Software Requirement Specification</li>
<li>TPS: Template Specification</li>
</ul>
<h2 id="CLASSIC-PLATFORM-1"><a href="#CLASSIC-PLATFORM-1" class="headerlink" title="CLASSIC PLATFORM"></a>CLASSIC PLATFORM</h2><h3 id="About"><a href="#About" class="headerlink" title="About"></a>About</h3><p>The AUTOSAR Classic Platform architecture distinguishes on the highest abstraction level between three software layers which run on a microcontroller: application, runtime environment (RTE) and basic software (BSW).</p>
<ul>
<li>The application software layer is mostly hardware independent.</li>
<li>Communication between software components and access to BSW via RTE.</li>
<li>The RTE represents the full interface for applications.</li>
<li>The BSW is divided in three major layers and complex drivers:<ul>
<li>Services, ECU (Electronic Control Unit) abstraction and microcontroller abstraction.</li>
</ul>
</li>
<li>Services are divided furthermore into functional groups representing the infrastructure for system, memory and communication services.</li>
</ul>
<h3 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h3><h4 id="VIRTUAL-FUNCTIONAL-BUS-VFB-–-THE-BACKBONE"><a href="#VIRTUAL-FUNCTIONAL-BUS-VFB-–-THE-BACKBONE" class="headerlink" title="VIRTUAL FUNCTIONAL BUS(VFB) – THE BACKBONE"></a>VIRTUAL FUNCTIONAL BUS(VFB) – THE BACKBONE</h4><p>One essential concept is the virtual functional bus (VFB). This virtual bus decouples the applications from the infrastructure. It communicates via dedicated ports, which means that the communication interfaces of the application software must be mapped to these ports. The VFB handles communication both within the individual ECU and between ECUs. From an application point of view, no detailed knowledge of lower-level technologies or dependencies is required. This supports hardware-independent development and usage of application software.</p>
<h4 id="AUTOSAR-CLASSIC-PLATFORM-ARCHITECTURE"><a href="#AUTOSAR-CLASSIC-PLATFORM-ARCHITECTURE" class="headerlink" title="AUTOSAR CLASSIC PLATFORM ARCHITECTURE"></a>AUTOSAR CLASSIC PLATFORM ARCHITECTURE</h4><p>Refer autosar.architecture.drawio for the architecture of autosar classic platform defined by AUTOSAR.</p>
<p>The AUTOSAR layered architecture is offering all the mechanisms needed for software and hardware independence. It distinguishes between three main software layers which run on a Microcontroller (µC): application layer, runtime environment (RTE), and basic software (BSW).</p>
<p>The applications of the different automotive domains interface the basic software by means of the RTE.</p>
<p>In addition to defining architecture and interfaces, AUTOSAR also defines a methodology which enables the configuration of the complete AUTOSAR stack and enhances interoperability between different tool chains. On the one hand this is important for the collaboration within development projects and on the other hand this is important to cut down development costs.</p>
<h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>The main concept of the standardized ECU software architecture is the separation of hardware-independent application software and hardware-oriented basic software (BSW) by means of the software abstraction layer RTE (runtime environment). On the upper side of the RTE, this abstraction layer enables the development of OEM-specific and competitive software applications. On the lower side of the RTE, it enables the standardization and OEM-independence of basic software. Further characteristics of the AUTOSAR software architecture are the scalability of ECU software for several car lines and variants, the possibility to distribute applications (functional software modules) across ECUs, and the ability to integrate software modules from different sources.</p>
<p>The basic software within the AUTOSAR software architecture is further divided into the following layers: services, ECU abstraction, and microcontroller abstraction. The separation of the application layer from the basic software, realized by the RTE, includes the control of the data exchange between these layers. This forms the basis for a component-oriented, hardware-independent software structure on application level, with software components (SWCs) as individual units. Because of their hardware independence, it is thus possible to develop SWCs without specific knowledge of the hardware used or planned, as well as to flexibly relocate existing SWCs to ECUs during development.</p>
<h3 id="Methodology-and-Templates"><a href="#Methodology-and-Templates" class="headerlink" title="Methodology and Templates"></a>Methodology and Templates</h3><p>In addition to a software architecture, AUTOSAR introduced a harmonized methodology approach for the development of automotive software. This is mainly driven by the need to improve the collaboration between the different parties involved in today’s automotive projects.  </p>
<p>AUTOSAR provides means to specify all aspects necessary to integrate a software component on an ECU and to integrate different ECUs to the whole network communication over a variety of different bus systems. The methodology defines the dependencies of activities on work products and is foreseen to support activities, descriptions and usage of tools in AUTOSAR.</p>
<p>The descriptions (.arxml) are based on the AUTOSAR Templates which define the formal exchange format (AUTOSAR Schema) and the semantic constraints which go along with the exchange format.  The descriptions are used to hold the information that is produced or consumed in the AUTOSAR methodology. Various generators can utilize the information from the descriptions to support the configuration and generation of the RTE and the AUTOSAR basic software (including the operating system).</p>
<h2 id="ADAPTIVE-PLATFORM-1"><a href="#ADAPTIVE-PLATFORM-1" class="headerlink" title="ADAPTIVE PLATFORM"></a>ADAPTIVE PLATFORM</h2><h3 id="About-1"><a href="#About-1" class="headerlink" title="About"></a>About</h3><p>The AUTOSAR Adaptive Platform implements the AUTOSAR Runtime for Adaptive Applications (ARA). Two types of interfaces are available, services and APIs. The platform consists of functional clusters which are grouped in services and the AUTOSAR Adaptive Basis.</p>
<p>In comparison to the AUTOSAR Classic Platform the AUTOSAR Runtime Environment for the Adaptive Platform dynamically links services and clients during runtime.</p>
<h3 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h3><p>AUTOSAR extends the existing Methodology to be able to have a common Methodology approach for both: Classic and Adaptive Platform. The support for distributed, independent, and agile development of functional applications requires a standardized approach on the development methodology. AUTOSAR adaptive methodology involves the standardization of work products and their respective tasks. Work products describe artifacts such as services, applications, machines, and their configuration. The respective tasks define how the work products exchange design information for the activities required which are needed to develop products based on the adaptive platform.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-FreeRTOS-STM32F429" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2024-12-31T01:03:56.476Z"><a href="/2024/12/31/FreeRTOS-STM32F429/">2024-12-31</a></time>
      
      
  
    <h1 class="title"><a href="/2024/12/31/FreeRTOS-STM32F429/">FreeRTOS: An Introduction and Porting Guide for STM32F429</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="Introduction-to-FreeRTOS"><a href="#Introduction-to-FreeRTOS" class="headerlink" title="Introduction to FreeRTOS"></a>Introduction to FreeRTOS</h2><p>FreeRTOS is a popular real-time operating system (RTOS) designed for embedded systems, providing a robust and lightweight solution for developing complex, time-critical applications. Developed by Real Time Engineers Ltd., FreeRTOS has become a go-to choice for microcontroller-based projects across various industries, including automotive, industrial automation, and consumer electronics.</p>
<h3 id="What-is-an-RTOS"><a href="#What-is-an-RTOS" class="headerlink" title="What is an RTOS?"></a>What is an RTOS?</h3><p>A Real-Time Operating System (RTOS) is specifically designed to handle time-sensitive tasks with predictable and deterministic timing. Unlike general-purpose operating systems, an RTOS ensures that critical tasks are completed within strict time constraints, making it essential for applications where timing is crucial.</p>
<h2 id="Core-Features-of-FreeRTOS"><a href="#Core-Features-of-FreeRTOS" class="headerlink" title="Core Features of FreeRTOS"></a>Core Features of FreeRTOS</h2><h3 id="1-Task-Management"><a href="#1-Task-Management" class="headerlink" title="1. Task Management"></a>1. Task Management</h3><p>FreeRTOS implements a priority-based preemptive scheduling mechanism. Key characteristics include:</p>
<ul>
<li>Flexible task creation and management</li>
<li>Support for multiple task priorities</li>
<li>Dynamic task creation and deletion</li>
<li>Lightweight task switching mechanism</li>
</ul>
<h3 id="2-Synchronization-Primitives"><a href="#2-Synchronization-Primitives" class="headerlink" title="2. Synchronization Primitives"></a>2. Synchronization Primitives</h3><p>The operating system provides robust synchronization mechanisms:</p>
<ul>
<li>Mutexes for resource protection</li>
<li>Semaphores for task synchronization</li>
<li>Queues for inter-task communication</li>
<li>Event groups for complex synchronization scenarios</li>
</ul>
<h3 id="3-Memory-Management"><a href="#3-Memory-Management" class="headerlink" title="3. Memory Management"></a>3. Memory Management</h3><p>FreeRTOS offers multiple memory allocation strategies:</p>
<ul>
<li>Static memory allocation</li>
<li>Dynamic memory allocation</li>
<li>Heap memory management with configurable allocation schemes</li>
</ul>
<h3 id="4-Low-Resource-Footprint"><a href="#4-Low-Resource-Footprint" class="headerlink" title="4. Low Resource Footprint"></a>4. Low Resource Footprint</h3><p>Designed for resource-constrained environments, FreeRTOS:</p>
<ul>
<li>Requires minimal RAM and ROM</li>
<li>Offers configurable kernel features</li>
<li>Supports a wide range of microcontrollers and architectures</li>
</ul>
<h2 id="Porting-FreeRTOS-to-STM32F429"><a href="#Porting-FreeRTOS-to-STM32F429" class="headerlink" title="Porting FreeRTOS to STM32F429"></a>Porting FreeRTOS to STM32F429</h2><h3 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h3><p>Before porting FreeRTOS to STM32F429, ensure you have:</p>
<ul>
<li>STM32F429 development board</li>
<li>MDK-ARM (Keil uVision) or equivalent development environment</li>
<li>FreeRTOS source code</li>
<li>STM32F429 hardware reference manual</li>
</ul>
<h3 id="Step-by-Step-Porting-Process"><a href="#Step-by-Step-Porting-Process" class="headerlink" title="Step-by-Step Porting Process"></a>Step-by-Step Porting Process</h3><h4 id="1-Project-Setup"><a href="#1-Project-Setup" class="headerlink" title="1. Project Setup"></a>1. Project Setup</h4><ol>
<li>Create a new MDK-ARM project for STM32F429</li>
<li>Include FreeRTOS source files in your project</li>
<li>Configure project include paths</li>
</ol>
<h4 id="2-Port-Specific-Configuration"><a href="#2-Port-Specific-Configuration" class="headerlink" title="2. Port-Specific Configuration"></a>2. Port-Specific Configuration</h4><p>Modify <code>FreeRTOSConfig.h</code> to customize the RTOS for STM32F429:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ    ( SystemCoreClock )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ    ( ( TickType_t ) 1000 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE ( ( size_t ) ( 64 * 1024 ) )</span></span><br></pre></td></tr></table></figure>

<h4 id="3-Implement-Processor-Specific-Ports"><a href="#3-Implement-Processor-Specific-Ports" class="headerlink" title="3. Implement Processor-Specific Ports"></a>3. Implement Processor-Specific Ports</h4><p>Create port files specific to ARM Cortex-M4:</p>
<ul>
<li><code>port.c</code>: Contains context switching and interrupt handling</li>
<li><code>portmacro.h</code>: Defines processor-specific macros</li>
</ul>
<h4 id="4-Interrupt-Management"><a href="#4-Interrupt-Management" class="headerlink" title="4. Interrupt Management"></a>4. Interrupt Management</h4><p>Configure system timer and PendSV interrupt for task switching:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> (INCLUDE_xTaskGetSchedulerState == 1)</span></span><br><span class="line">        <span class="keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            xPortSysTickHandler();</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> (INCLUDE_xTaskGetSchedulerState == 1)</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-Basic-Task-Creation-Example"><a href="#5-Basic-Task-Creation-Example" class="headerlink" title="5. Basic Task Creation Example"></a>5. Basic Task Creation Example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskMain</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// Task implementation</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Hardware initialization</span></span><br><span class="line">    </span><br><span class="line">    xTaskCreate(vTaskMain, </span><br><span class="line">                <span class="string">&quot;MainTask&quot;</span>, </span><br><span class="line">                configMINIMAL_STACK_SIZE, </span><br><span class="line">                <span class="literal">NULL</span>, </span><br><span class="line">                tskIDLE_PRIORITY, </span><br><span class="line">                <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Should never reach here</span></span><br><span class="line">    <span class="keyword">for</span> (;;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Common-Challenges-and-Solutions"><a href="#Common-Challenges-and-Solutions" class="headerlink" title="Common Challenges and Solutions"></a>Common Challenges and Solutions</h3><ol>
<li><strong>Interrupt Handling</strong>: Carefully manage interrupt priorities and nesting</li>
<li><strong>Memory Constraints</strong>: Optimize memory usage through static allocation</li>
<li><strong>Timing Precision</strong>: Calibrate system tick and task scheduling</li>
</ol>
<h2 id="Best-Practices"><a href="#Best-Practices" class="headerlink" title="Best Practices"></a>Best Practices</h2><ul>
<li>Use static allocation when possible</li>
<li>Implement proper task priority management</li>
<li>Utilize built-in synchronization primitives</li>
<li>Regularly profile and optimize task performance</li>
<li>Implement error handling and monitoring mechanisms</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>[O<br>Porting FreeRTOS to STM32F429 provides a powerful framework for developing real-time embedded applications. By understanding the core features and following a systematic porting approach, developers can leverage the full potential of both the microcontroller and the real-time operating system.</p>
<h2 id="Reference-Implementation-Details"><a href="#Reference-Implementation-Details" class="headerlink" title="Reference Implementation Details"></a>Reference Implementation Details</h2><h3 id="Key-Code-Snippets-from-apexpeng-FreeRTOS-STM32F429"><a href="#Key-Code-Snippets-from-apexpeng-FreeRTOS-STM32F429" class="headerlink" title="Key Code Snippets from apexpeng&#x2F;FreeRTOS_STM32F429"></a>Key Code Snippets from apexpeng&#x2F;FreeRTOS_STM32F429</h3><h4 id="1-System-Initialization-main-c"><a href="#1-System-Initialization-main-c" class="headerlink" title="1. System Initialization (main.c)"></a>1. System Initialization (main.c)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// System Clock Configuration</span></span><br><span class="line">    SystemInit();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// NVIC Priority Grouping Configuration</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LED Initialization</span></span><br><span class="line">    LED_Init();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// USART Initialization for Debugging</span></span><br><span class="line">    USART1_Init();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create Tasks</span></span><br><span class="line">    xTaskCreate(LED0_Task, <span class="string">&quot;LED0 Task&quot;</span>, <span class="number">50</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(LED1_Task, <span class="string">&quot;LED1 Task&quot;</span>, <span class="number">50</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Start FreeRTOS Scheduler</span></span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Should never reach here</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Task-Implementation-Example"><a href="#2-Task-Implementation-Example" class="headerlink" title="2. Task Implementation Example"></a>2. Task Implementation Example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LED0_Task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED0_Toggle();</span><br><span class="line">        vTaskDelay(<span class="number">500</span>);  <span class="comment">// Delay for 500 milliseconds</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED1_Toggle();</span><br><span class="line">        vTaskDelay(<span class="number">800</span>);  <span class="comment">// Delay for 800 milliseconds</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-FreeRTOS-Configuration-FreeRTOSConfig-h"><a href="#3-FreeRTOS-Configuration-FreeRTOSConfig-h" class="headerlink" title="3. FreeRTOS Configuration (FreeRTOSConfig.h)"></a>3. FreeRTOS Configuration (FreeRTOSConfig.h)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PREEMPTION              1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TICKLESS_IDLE           0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ                ( SystemCoreClock )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ                ( ( TickType_t ) 1000 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_PRIORITIES              ( 5 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMINIMAL_STACK_SIZE          ( ( uint16_t ) 128 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE             ( ( size_t ) ( 16 * 1024 ) )</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Interrupt-Handling-Example"><a href="#4-Interrupt-Handling-Example" class="headerlink" title="4. Interrupt Handling Example"></a>4. Interrupt Handling Example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint16_t</span> data = USART_ReceiveData(USART1);</span><br><span class="line">        <span class="comment">// Handle received data</span></span><br><span class="line">        USART_ClearITPendingBit(USART1, USART_IT_RXNE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Practical-Considerations"><a href="#Practical-Considerations" class="headerlink" title="Practical Considerations"></a>Practical Considerations</h3><p>The reference implementation demonstrates several critical aspects of FreeRTOS integration:</p>
<ul>
<li>Proper system initialization</li>
<li>Task creation with different priorities</li>
<li>Simple task implementations</li>
<li>Interrupt handling</li>
<li>Minimal configuration for STM32F429</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.freertos.org/documentation/">FreeRTOS Official Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://www.st.com/resource/en/reference_manual/rm0090-stm32f405-415-stm32f407-417-stm32f427-437-and-stm32f429-439-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf">STM32F429 Reference Manual</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apexpeng/FreeRTOS_STM32F429">GitHub Repository: apexpeng&#x2F;FreeRTOS_STM32F429</a></li>
</ul>
<p><strong>NOTE</strong>: The DAC function only works fine before tasks scheduler, the clock need to be set to fix this issue.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/3/" class="alignleft prev">Prev</a>
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="apexpeng.github.io">
  </form>
</div>


  

  

  
  <div class="widget widget-archives">
    <h3 class="title">Archives</h3>
    <div class="entry">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a><span class="archive-list-count">33</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2025 apexpenn
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
