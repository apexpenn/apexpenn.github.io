<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Penn&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Our life is shaped by our mind; we become what we think.">
<meta property="og:type" content="website">
<meta property="og:title" content="Penn&#39;s Blog">
<meta property="og:url" content="https://apexpeng.github.io/page/2/index.html">
<meta property="og:site_name" content="Penn&#39;s Blog">
<meta property="og:description" content="Our life is shaped by our mind; we become what we think.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zhang Peng">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Penn's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Penn&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://apexpeng.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-compress-intro" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/31/compress-intro/" class="article-date">
  <time class="dt-published" datetime="2024-12-31T01:03:56.491Z" itemprop="datePublished">2024-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/31/compress-intro/">Comprehensive Guide to Data Compression Technologies</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Executive-Summary"><a href="#Executive-Summary" class="headerlink" title="Executive Summary"></a>Executive Summary</h2><p>Data compression is a critical technology that underpins modern digital information management, enabling efficient storage, transmission, and processing across diverse computing environments. This comprehensive guide provides an in-depth exploration of compression technologies, spanning historical developments, algorithmic approaches, implementation strategies, and future trends.</p>
<h2 id="1-Historical-Evolution-of-Data-Compression"><a href="#1-Historical-Evolution-of-Data-Compression" class="headerlink" title="1. Historical Evolution of Data Compression"></a>1. Historical Evolution of Data Compression</h2><h3 id="1-1-Early-Developments"><a href="#1-1-Early-Developments" class="headerlink" title="1.1 Early Developments"></a>1.1 Early Developments</h3><p>The foundations of data compression trace back to pivotal moments in information theory:</p>
<ul>
<li><strong>1950s</strong>: Claude Shannon’s groundbreaking work in information theory laid the theoretical groundwork</li>
<li><strong>1952</strong>: First run-length encoding (RLE) techniques emerged</li>
<li><strong>1977</strong>: Huffman coding developed, revolutionizing lossless compression</li>
<li><strong>1980s</strong>: LZW (Lempel-Ziv-Welch) algorithm transformed text and image compression</li>
<li><strong>1990s-2000s</strong>: Advanced compression techniques for multimedia and big data</li>
<li><strong>2010s-Present</strong>: Machine learning and hardware-accelerated compression technologies</li>
</ul>
<h2 id="2-Fundamental-Compression-Categories"><a href="#2-Fundamental-Compression-Categories" class="headerlink" title="2. Fundamental Compression Categories"></a>2. Fundamental Compression Categories</h2><h3 id="2-1-Lossless-Compression"><a href="#2-1-Lossless-Compression" class="headerlink" title="2.1 Lossless Compression"></a>2.1 Lossless Compression</h3><p>Technique that perfectly reconstructs original data without any information loss.</p>
<h4 id="2-1-1-Key-Algorithms"><a href="#2-1-1-Key-Algorithms" class="headerlink" title="2.1.1 Key Algorithms"></a>2.1.1 Key Algorithms</h4><ol>
<li><p><strong>Huffman Coding</strong></p>
<ul>
<li><strong>Principle</strong>: Variable-length coding based on character frequencies</li>
<li><strong>Compression Ratio</strong>: 20-90% reduction</li>
<li><strong>Ideal Use Cases</strong>: Text files, archives, configuration data</li>
<li><strong>Performance</strong>:<ul>
<li>Time Complexity: O(n log n)</li>
<li>Space Complexity: O(n)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Run-Length Encoding (RLE)</strong></p>
<ul>
<li><strong>Principle</strong>: Replaces consecutive data sequences with a single data value and count</li>
<li><strong>Compression Ratio</strong>: 50-90% for repetitive data</li>
<li><strong>Ideal Use Cases</strong>: Simple graphics, monochrome images</li>
<li><strong>Performance</strong>:<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(1)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Lempel-Ziv-Welch (LZW)</strong></p>
<ul>
<li><strong>Principle</strong>: Dictionary-based compression building dynamic dictionaries</li>
<li><strong>Compression Ratio</strong>: 40-70%</li>
<li><strong>Ideal Use Cases</strong>: GIF image format, Unix compress utility</li>
<li><strong>Performance</strong>:<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(2^k), where k is dictionary size</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-2-Lossy-Compression"><a href="#2-2-Lossy-Compression" class="headerlink" title="2.2 Lossy Compression"></a>2.2 Lossy Compression</h3><p>Technique that reduces file size by removing less critical data, accepting some quality loss.</p>
<h4 id="2-2-1-Key-Algorithms"><a href="#2-2-1-Key-Algorithms" class="headerlink" title="2.2.1 Key Algorithms"></a>2.2.1 Key Algorithms</h4><ol>
<li><p><strong>JPEG Compression</strong></p>
<ul>
<li><strong>Principle</strong>: Discrete Cosine Transform (DCT) with quantization</li>
<li><strong>Compression Ratio</strong>: 10:1 to 100:1</li>
<li><strong>Ideal Use Cases</strong>: Photographic images</li>
<li><strong>Performance</strong>:<ul>
<li>Compression Speed: Moderate</li>
<li>Quality Preservation: Configurable</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>MP3 Audio Compression</strong></p>
<ul>
<li><strong>Principle</strong>: Psychoacoustic model removing imperceptible sound frequencies</li>
<li><strong>Compression Ratio</strong>: 90-95%</li>
<li><strong>Ideal Use Cases</strong>: Music and audio files</li>
<li><strong>Performance</strong>:<ul>
<li>Compression Speed: Fast</li>
<li>Quality Preservation: High</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="3-Advanced-Compression-Implementations"><a href="#3-Advanced-Compression-Implementations" class="headerlink" title="3. Advanced Compression Implementations"></a>3. Advanced Compression Implementations</h2><h3 id="3-1-7-Zip-Compression-Technology"><a href="#3-1-7-Zip-Compression-Technology" class="headerlink" title="3.1 7-Zip Compression Technology"></a>3.1 7-Zip Compression Technology</h3><h4 id="3-1-1-LZMA-Compression-Core-Method"><a href="#3-1-1-LZMA-Compression-Core-Method" class="headerlink" title="3.1.1 LZMA Compression Core Method"></a>3.1.1 LZMA Compression Core Method</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLzmaEncoder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Encode</span><span class="params">(ISequentialInStream *inStream, </span></span></span><br><span class="line"><span class="params"><span class="function">               ISequentialOutStream *outStream, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> UInt64 *inSize, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> UInt64 *outSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Advanced compression implementation</span></span><br><span class="line">        UInt32 dictionarySize = <span class="number">1</span> &lt;&lt; <span class="number">23</span>;  <span class="comment">// 8 MB default</span></span><br><span class="line">        UInt32 lc = <span class="number">3</span>, lp = <span class="number">0</span>, pb = <span class="number">2</span>;    <span class="comment">// Context bits configuration</span></span><br><span class="line">        </span><br><span class="line">        _encoder.<span class="built_in">SetDictionarySize</span>(dictionarySize);</span><br><span class="line">        _encoder.<span class="built_in">SetLcLpPbSettings</span>(lc, lp, pb);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _encoder.<span class="built_in">CodeReal</span>(inStream, outStream, inSize, outSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CLzmaEncoderInt _encoder;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-QATzip-Hardware-Accelerated-Compression"><a href="#3-2-QATzip-Hardware-Accelerated-Compression" class="headerlink" title="3.2 QATzip: Hardware-Accelerated Compression"></a>3.2 QATzip: Hardware-Accelerated Compression</h3><h4 id="3-2-1-Compression-Acceleration-Kernel"><a href="#3-2-1-Compression-Acceleration-Kernel" class="headerlink" title="3.2.1 Compression Acceleration Kernel"></a>3.2.1 Compression Acceleration Kernel</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">qzCompressData</span><span class="params">(</span></span><br><span class="line"><span class="params">    QzSession_T *sess,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *src,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> src_len,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">char</span> *dest,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> *dest_len</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="type">int</span> status = QZ_OK;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Hardware acceleration configuration</span></span><br><span class="line">    QzDataFormat_T data_format = QZ_DEFLATE;</span><br><span class="line">    QzCompressionLvl_T comp_lvl = QZ_COMP_LEVEL_DEFAULT;</span><br><span class="line">    </span><br><span class="line">    sess-&gt;config.data_fmt = data_format;</span><br><span class="line">    sess-&gt;config.comp_lvl = comp_lvl;</span><br><span class="line">    </span><br><span class="line">    status = qzCompress(</span><br><span class="line">        sess,           <span class="comment">// Compression session</span></span><br><span class="line">        src,            <span class="comment">// Source data</span></span><br><span class="line">        src_len,        <span class="comment">// Source length</span></span><br><span class="line">        dest,           <span class="comment">// Destination buffer</span></span><br><span class="line">        dest_len,       <span class="comment">// Destination length</span></span><br><span class="line">        <span class="number">1</span>               <span class="comment">// Last block flag</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-Intel-Quick-Assist-Technology-QAT"><a href="#3-3-Intel-Quick-Assist-Technology-QAT" class="headerlink" title="3.3 Intel Quick Assist Technology (QAT)"></a>3.3 Intel Quick Assist Technology (QAT)</h3><h4 id="3-3-1-Technology-Overview"><a href="#3-3-1-Technology-Overview" class="headerlink" title="3.3.1 Technology Overview"></a>3.3.1 Technology Overview</h4><p>Intel Quick Assist Technology (QAT) represents a breakthrough in hardware-accelerated data compression and cryptographic processing.</p>
<p><strong>Technical Specifications:</strong></p>
<ul>
<li><strong>Model</strong>: Intel QAT C62x Series</li>
<li><strong>Compression Standards</strong>: <ul>
<li>DEFLATE</li>
<li>LZ4</li>
<li>Snappy</li>
</ul>
</li>
<li><strong>Acceleration Capabilities</strong>:<ul>
<li>Compression&#x2F;Decompression</li>
<li>Cryptographic Operations</li>
<li>SSL&#x2F;TLS Processing</li>
</ul>
</li>
</ul>
<p><strong>Performance Characteristics:</strong></p>
<ul>
<li>Compression Throughput: Up to 100 Gbps</li>
<li>Latency Reduction: 50-70% compared to software-only solutions</li>
<li>Power Efficiency: Significantly lower CPU utilization</li>
</ul>
<h2 id="4-Benchmarking-and-Evaluation-Methodologies"><a href="#4-Benchmarking-and-Evaluation-Methodologies" class="headerlink" title="4. Benchmarking and Evaluation Methodologies"></a>4. Benchmarking and Evaluation Methodologies</h2><h3 id="4-1-Benchmark-Principles"><a href="#4-1-Benchmark-Principles" class="headerlink" title="4.1 Benchmark Principles"></a>4.1 Benchmark Principles</h3><ol>
<li><strong>Compression Ratio</strong>: Measure of data size reduction</li>
<li><strong>Compression&#x2F;Decompression Speed</strong>: Processing time efficiency</li>
<li><strong>Computational Complexity</strong>: Algorithmic resource requirements</li>
<li><strong>Memory Usage</strong>: Storage and runtime memory consumption</li>
<li><strong>Data Type Compatibility</strong>: Effectiveness across different data types</li>
</ol>
<h3 id="4-2-Benchmark-Methodology"><a href="#4-2-Benchmark-Methodology" class="headerlink" title="4.2 Benchmark Methodology"></a>4.2 Benchmark Methodology</h3><ul>
<li>Standardized test datasets</li>
<li>Controlled experimental environments</li>
<li>Multiple metric evaluation</li>
<li>Reproducibility of results</li>
<li>Comprehensive performance profiling</li>
</ul>
<h2 id="5-Industry-Applications-and-Use-Cases"><a href="#5-Industry-Applications-and-Use-Cases" class="headerlink" title="5. Industry Applications and Use Cases"></a>5. Industry Applications and Use Cases</h2><h3 id="5-1-Diverse-Application-Domains"><a href="#5-1-Diverse-Application-Domains" class="headerlink" title="5.1 Diverse Application Domains"></a>5.1 Diverse Application Domains</h3><ol>
<li><p><strong>Cloud Computing</strong></p>
<ul>
<li>Storage optimization</li>
<li>Bandwidth reduction</li>
<li>Cost-effective data management</li>
</ul>
</li>
<li><p><strong>Network Transmission</strong></p>
<ul>
<li>Reduced data transfer times</li>
<li>Improved network efficiency</li>
<li>Lower bandwidth consumption</li>
</ul>
</li>
<li><p><strong>Multimedia Processing</strong></p>
<ul>
<li>Video streaming</li>
<li>Image and audio compression</li>
<li>Content delivery optimization</li>
</ul>
</li>
<li><p><strong>Scientific Computing</strong></p>
<ul>
<li>Large dataset management</li>
<li>Research data preservation</li>
<li>High-performance computing</li>
</ul>
</li>
</ol>
<h2 id="6-Emerging-Technologies-and-Future-Trends"><a href="#6-Emerging-Technologies-and-Future-Trends" class="headerlink" title="6. Emerging Technologies and Future Trends"></a>6. Emerging Technologies and Future Trends</h2><h3 id="6-1-Next-Generation-Compression-Innovations"><a href="#6-1-Next-Generation-Compression-Innovations" class="headerlink" title="6.1 Next-Generation Compression Innovations"></a>6.1 Next-Generation Compression Innovations</h3><ol>
<li><p><strong>Artificial Intelligence-Driven Compression</strong></p>
<ul>
<li>Machine learning adaptive algorithms</li>
<li>Context-aware compression techniques</li>
<li>Dynamic compression strategies</li>
</ul>
</li>
<li><p><strong>Quantum Computing Integration</strong></p>
<ul>
<li>Quantum information theory applications</li>
<li>Advanced error correction methods</li>
<li>Probabilistic compression algorithms</li>
</ul>
</li>
<li><p><strong>Edge Computing Optimization</strong></p>
<ul>
<li>Localized compression techniques</li>
<li>Low-latency compression for IoT devices</li>
<li>Energy-efficient compression algorithms</li>
</ul>
</li>
</ol>
<h2 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7. Conclusion"></a>7. Conclusion</h2><p>Data compression remains a dynamic and critical technology in managing the exponential growth of digital information. As computational landscapes evolve, compression techniques continue to advance, addressing challenges in storage, transmission, and processing efficiency.</p>
<p>The future of compression lies in intelligent, adaptive approaches that balance performance, resource utilization, and data integrity across diverse computing environments.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li>Shannon, C. E. (1948). A Mathematical Theory of Communication</li>
<li>Huffman, D. A. (1952). A Method for the Construction of Minimum-Redundancy Codes</li>
<li>Welch, T. A. (1984). A Technique for High-Performance Data Compression</li>
<li>Intel® QuickAssist Technology (QAT) Software Developer Manual</li>
<li>7-Zip LZMA SDK Documentation</li>
</ol>
<hr>
<p><strong>Disclaimer</strong>: Performance metrics and compression ratios are approximate and may vary based on specific implementation, data characteristics, and hardware configurations.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://apexpeng.github.io/2024/12/31/compress-intro/" data-id="cm5c7gmu9000ddgvydnw9edpu" data-title="Comprehensive Guide to Data Compression Technologies" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux-i2c-lm87" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/31/linux-i2c-lm87/" class="article-date">
  <time class="dt-published" datetime="2024-12-31T01:03:56.491Z" itemprop="datePublished">2024-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/31/linux-i2c-lm87/">Understanding Linux I2C, SMBus, and Platform Subsystems: A Comprehensive Guide</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Linux provides a robust framework for hardware interaction, enabling developers to write device drivers for various subsystems. This article explores the Linux I2C (Inter-Integrated Circuit), SMBus (System Management Bus), and platform subsystems, providing an overview of their architecture and implementation. We also introduce <code>sysfs</code> for hardware monitoring and show a practical example of an I2C sensor driver.</p>
<hr>
<h2 id="Introduction-to-Linux-I2C-and-SMBus"><a href="#Introduction-to-Linux-I2C-and-SMBus" class="headerlink" title="Introduction to Linux I2C and SMBus"></a><strong>Introduction to Linux I2C and SMBus</strong></h2><h3 id="I2C-Overview"><a href="#I2C-Overview" class="headerlink" title="I2C Overview"></a><strong>I2C Overview</strong></h3><p>The I2C protocol is a simple, efficient, and widely used bus protocol for communication between a master device (e.g., microcontroller) and multiple slave devices (e.g., sensors, EEPROMs). I2C operates using two bidirectional lines:</p>
<ul>
<li><strong>SDA (Serial Data Line)</strong>: For data transfer.</li>
<li><strong>SCL (Serial Clock Line)</strong>: For clock synchronization.</li>
</ul>
<p>The Linux kernel provides a standardized framework to implement I2C bus and device drivers.</p>
<h3 id="SMBus-Overview"><a href="#SMBus-Overview" class="headerlink" title="SMBus Overview"></a><strong>SMBus Overview</strong></h3><p>SMBus, built atop the I2C protocol, is specifically designed for system management tasks, such as monitoring voltages, temperatures, and fan speeds. It supports stricter timing and message formatting requirements compared to I2C, ensuring compatibility with system management devices.</p>
<hr>
<h2 id="Sysfs-in-the-Linux-Kernel"><a href="#Sysfs-in-the-Linux-Kernel" class="headerlink" title="Sysfs in the Linux Kernel"></a><strong>Sysfs in the Linux Kernel</strong></h2><p><code>sysfs</code> is a virtual filesystem in Linux, providing a user-space interface to kernel objects and their attributes. For hardware devices:</p>
<ul>
<li><code>sysfs</code> exposes attributes in <code>/sys/class</code> or <code>/sys/devices</code>.</li>
<li>It enables user-space applications to query or modify hardware settings.</li>
</ul>
<p>For example, the <code>hwmon</code> subsystem uses <code>sysfs</code> to expose sensor readings like temperature, voltage, and fan speed.</p>
<hr>
<h2 id="Platform-Subsystem-in-Linux"><a href="#Platform-Subsystem-in-Linux" class="headerlink" title="Platform Subsystem in Linux"></a><strong>Platform Subsystem in Linux</strong></h2><p>The <strong>platform subsystem</strong> is used for devices integrated directly into the system’s motherboard or SoC. Unlike hot-pluggable buses like USB, platform devices are usually initialized during boot.</p>
<ul>
<li><strong>Platform Device</strong>: Represents the hardware component.</li>
<li><strong>Platform Driver</strong>: Interfaces with the platform device, enabling kernel interaction.</li>
</ul>
<p>Platform devices and drivers communicate via platform data, often defined in the Device Tree or ACPI tables.</p>
<hr>
<h2 id="hwmon-Subsystem"><a href="#hwmon-Subsystem" class="headerlink" title="hwmon Subsystem"></a><strong>hwmon Subsystem</strong></h2><p>The <code>hwmon</code> (Hardware Monitoring) subsystem is responsible for monitoring system hardware like temperatures, voltages, and fan speeds. It uses:</p>
<ul>
<li><strong>I2C or SMBus drivers</strong> to read sensor data.</li>
<li><strong>sysfs</strong> to expose readings to user-space.</li>
</ul>
<hr>
<h2 id="Writing-an-I2C-Driver"><a href="#Writing-an-I2C-Driver" class="headerlink" title="Writing an I2C Driver"></a><strong>Writing an I2C Driver</strong></h2><h3 id="I2C-Bus-Driver"><a href="#I2C-Bus-Driver" class="headerlink" title="I2C Bus Driver"></a><strong>I2C Bus Driver</strong></h3><p>The bus driver manages the physical I2C controller. A basic I2C adapter registration looks like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> <span class="title">my_i2c_adapter</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .name = <span class="string">&quot;my_i2c_adapter&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_i2c_bus_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> i2c_add_adapter(&amp;my_i2c_adapter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_i2c_bus_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    i2c_del_adapter(&amp;my_i2c_adapter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_i2c_bus_init);</span><br><span class="line">module_exit(my_i2c_bus_exit);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Author&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Basic I2C Bus Driver&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="I2C-Device-Driver"><a href="#I2C-Device-Driver" class="headerlink" title="I2C Device Driver"></a><strong>I2C Device Driver</strong></h3><p>The device driver communicates with the specific I2C slave device. A typical implementation includes probing the device and defining read&#x2F;write functions.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_i2c_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Probing device: %s\n&quot;</span>, client-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_i2c_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Removing device: %s\n&quot;</span>, client-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">my_i2c_id</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;my_device&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">my_i2c_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_i2c_driver&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = my_i2c_probe,</span><br><span class="line">    .remove = my_i2c_remove,</span><br><span class="line">    .id_table = my_i2c_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_i2c_driver(my_i2c_driver);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Author&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Basic I2C Device Driver&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Example-I2C-Sensor-Driver-LM87"><a href="#Example-I2C-Sensor-Driver-LM87" class="headerlink" title="Example: I2C Sensor Driver (LM87)"></a><strong>Example: I2C Sensor Driver (LM87)</strong></h2><p>The <a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/common/+/refs/heads/android-mainline/drivers/hwmon/lm87.c">LM87</a> driver is an excellent example of integrating an I2C sensor with the <code>hwmon</code> subsystem.</p>
<h3 id="Key-Functions-in-lm87-c"><a href="#Key-Functions-in-lm87-c" class="headerlink" title="Key Functions in lm87.c"></a><strong>Key Functions in <code>lm87.c</code></strong></h3><h4 id="1-Probe-Function"><a href="#1-Probe-Function" class="headerlink" title="1. Probe Function"></a>1. <strong>Probe Function</strong></h4><p>Registers the device with the <code>hwmon</code> subsystem:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">lm87_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Initialization and hardware setup</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    hwmon_device_register_with_info(client-&gt;dev, <span class="string">&quot;lm87&quot;</span>, data, &amp;lm87_chip_info, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Sysfs-Interface"><a href="#2-Sysfs-Interface" class="headerlink" title="2. Sysfs Interface"></a>2. <strong>Sysfs Interface</strong></h4><p>Exposes sensor data through <code>sysfs</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">show_temp_input</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Read temperature from sensor</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d\n&quot;</span>, temp_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Device-Initialization"><a href="#3-Device-Initialization" class="headerlink" title="3. Device Initialization"></a>3. <strong>Device Initialization</strong></h4><p>Defines the I2C client and ID table:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">lm87_id</span>[] =</span> &#123;</span><br><span class="line">    &#123; <span class="string">&quot;lm87&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">lm87_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;lm87&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe      = lm87_probe,</span><br><span class="line">    .id_table   = lm87_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_i2c_driver(lm87_driver);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h2><p>The Linux I2C, SMBus, and platform subsystems provide a robust framework for hardware monitoring and device driver development. The <code>lm87.c</code> driver demonstrates effective use of these subsystems, enabling developers to integrate I2C sensors seamlessly. Understanding these components equips developers to write efficient and maintainable drivers for a variety of devices.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://apexpeng.github.io/2024/12/31/linux-i2c-lm87/" data-id="cm5c7gmub000fdgvy3q451tob" data-title="Understanding Linux I2C, SMBus, and Platform Subsystems: A Comprehensive Guide" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux-devicedriver-intro" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/31/linux-devicedriver-intro/" class="article-date">
  <time class="dt-published" datetime="2024-12-31T01:03:56.491Z" itemprop="datePublished">2024-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/31/linux-devicedriver-intro/">Linux Device Driver Introduction</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Introduction-to-the-Linux-Kernel-Ecosystem"><a href="#Introduction-to-the-Linux-Kernel-Ecosystem" class="headerlink" title="Introduction to the Linux Kernel Ecosystem"></a>Introduction to the Linux Kernel Ecosystem</h2><p>The Linux kernel represents a complex and powerful operating system core that serves as the fundamental interface between computer hardware and software applications. As an open-source marvel, it manages system resources, provides essential services, and enables the seamless operation of diverse hardware configurations.</p>
<h2 id="System-Startup-From-U-Boot-to-Linux-Kernel-Initialization"><a href="#System-Startup-From-U-Boot-to-Linux-Kernel-Initialization" class="headerlink" title="System Startup: From U-Boot to Linux Kernel Initialization"></a>System Startup: From U-Boot to Linux Kernel Initialization</h2><h3 id="U-Boot-The-Initial-Bootloader"><a href="#U-Boot-The-Initial-Bootloader" class="headerlink" title="U-Boot: The Initial Bootloader"></a>U-Boot: The Initial Bootloader</h3><p>U-Boot (Universal Bootloader) plays a crucial role in the system startup process, especially in embedded systems and various hardware platforms. Its primary responsibilities include:</p>
<ol>
<li><p><strong>Hardware Initialization</strong>: U-Boot initializes critical hardware components, including:</p>
<ul>
<li>CPU configuration</li>
<li>Memory controller setup</li>
<li>Basic peripheral initialization</li>
</ul>
</li>
<li><p><strong>Image Loading</strong>: It loads the Linux kernel image from various storage mediums such as:</p>
<ul>
<li>Flash memory</li>
<li>SD cards</li>
<li>Network boot (TFTP)</li>
<li>USB storage</li>
</ul>
</li>
<li><p><strong>Environment Configuration</strong>: U-Boot sets up essential boot parameters, including:</p>
<ul>
<li>Kernel load address</li>
<li>Command-line arguments</li>
<li>Device tree blob location</li>
</ul>
</li>
</ol>
<h3 id="Linux-Kernel-Startup-Process"><a href="#Linux-Kernel-Startup-Process" class="headerlink" title="Linux Kernel Startup Process"></a>Linux Kernel Startup Process</h3><p>The Linux kernel initialization is a multi-stage process that transforms the system from a dormant state to a fully operational environment:</p>
<ol>
<li><p><strong>Kernel Entry Point</strong></p>
<ul>
<li>The kernel begins execution at its entry point defined in the architecture-specific startup code</li>
<li>Switches to supervisor mode</li>
<li>Sets up initial page tables</li>
<li>Configures CPU-specific features</li>
</ul>
</li>
<li><p><strong>Early Initialization</strong></p>
<ul>
<li>Validates and sets up memory management</li>
<li>Initializes essential data structures</li>
<li>Configures processor-specific features</li>
<li>Sets up interrupt handling mechanisms</li>
</ul>
</li>
<li><p><strong>Architecture-Independent Initialization</strong></p>
<ul>
<li>Mounts the initial RAM disk (initrd)</li>
<li>Starts the first user-space process (typically systemd)</li>
<li>Completes device and module initialization</li>
</ul>
</li>
</ol>
<h2 id="Virtual-Filesystem-VFS-in-Linux-Kernel"><a href="#Virtual-Filesystem-VFS-in-Linux-Kernel" class="headerlink" title="Virtual Filesystem (VFS) in Linux Kernel"></a>Virtual Filesystem (VFS) in Linux Kernel</h2><h3 id="Virtual-Filesystem-Concept"><a href="#Virtual-Filesystem-Concept" class="headerlink" title="Virtual Filesystem Concept"></a>Virtual Filesystem Concept</h3><p>The Virtual Filesystem (VFS) is a crucial abstraction layer in the Linux kernel that provides a unified interface for multiple filesystem types. It acts as an intermediary between user-space applications and various filesystem implementations.</p>
<h4 id="Key-VFS-Abstractions"><a href="#Key-VFS-Abstractions" class="headerlink" title="Key VFS Abstractions"></a>Key VFS Abstractions</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfs_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="keyword">struct</span> <span class="title">inode</span> *, <span class="keyword">struct</span> <span class="title">dentry</span> *, <span class="title">unsigned</span> <span class="title">int</span>);</span></span><br><span class="line">    <span class="type">int</span> (*create) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *, <span class="type">umode_t</span>, <span class="type">bool</span>);</span><br><span class="line">    <span class="type">int</span> (*mkdir) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *, <span class="type">umode_t</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> fs_flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>) (<span class="keyword">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>, </span></span><br><span class="line"><span class="class">                              <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span></span><br><span class="line">    <span class="type">void</span> (*kill_sb) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="VFS-Integration-with-Linux-Kernel"><a href="#VFS-Integration-with-Linux-Kernel" class="headerlink" title="VFS Integration with Linux Kernel"></a>VFS Integration with Linux Kernel</h3><p>The VFS provides a common interface for:</p>
<ol>
<li>File operations across different filesystem types</li>
<li>Filesystem-independent file handling</li>
<li>Unified system call implementation</li>
</ol>
<h2 id="Linux-Device-Driver-Fundamentals"><a href="#Linux-Device-Driver-Fundamentals" class="headerlink" title="Linux Device Driver Fundamentals"></a>Linux Device Driver Fundamentals</h2><h3 id="Device-Driver-Classification"><a href="#Device-Driver-Classification" class="headerlink" title="Device Driver Classification"></a>Device Driver Classification</h3><p>Linux supports three primary types of device drivers:</p>
<ol>
<li><p><strong>Character Device Drivers</strong></p>
<ul>
<li>Handle data streams as sequential character sequences</li>
<li>Support operations like read(), write(), open(), close()</li>
<li>Examples: Serial ports, keyboards, sound cards</li>
<li>Implemented using <code>struct cdev</code></li>
<li>Key operations managed through file operations structure</li>
</ul>
</li>
<li><p><strong>Block Device Drivers</strong></p>
<ul>
<li>Manage block-oriented storage devices</li>
<li>Support random access to fixed-size blocks</li>
<li>Examples: Hard drives, SSDs, RAM disks</li>
<li>Utilize block I&#x2F;O request queue mechanisms</li>
<li>Implement advanced caching and optimization strategies</li>
</ul>
</li>
<li><p><strong>Network Device Drivers</strong></p>
<ul>
<li>Manage network interface communication</li>
<li>Handle packet transmission and reception</li>
<li>Implement protocol-specific communication layers</li>
<li>Utilize Linux networking stack abstractions</li>
<li>Provide standard network interface operations</li>
</ul>
</li>
</ol>
<h2 id="Practical-Device-Driver-Implementation"><a href="#Practical-Device-Driver-Implementation" class="headerlink" title="Practical Device Driver Implementation"></a>Practical Device Driver Implementation</h2><h3 id="Char-Device-Driver-Comprehensive-Example"><a href="#Char-Device-Driver-Comprehensive-Example" class="headerlink" title="Char Device Driver: Comprehensive Example"></a>Char Device Driver: Comprehensive Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;simple_char_dev&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS_NAME  <span class="string">&quot;simple_char_class&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> majorNumber;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> message[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">short</span> size_of_message;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span>*  <span class="title">charClass</span>  =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span>* <span class="title">charDevice</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">charCdev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prototype functions</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span>     <span class="title function_">dev_open</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span>     <span class="title function_">dev_release</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">dev_read</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">dev_write</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File operations structure</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">    .open = dev_open,</span><br><span class="line">    .read = dev_read,</span><br><span class="line">    .write = dev_write,</span><br><span class="line">    .release = dev_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Module initialization and exit functions (implementation omitted for brevity)</span></span><br></pre></td></tr></table></figure>

<h3 id="Procfs-Integration-Example"><a href="#Procfs-Integration-Example" class="headerlink" title="Procfs Integration Example"></a>Procfs Integration Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROC_NAME <span class="string">&quot;driver_status&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFFER 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_file</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kernel_buffer[MAX_BUFFER];</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> procfs_buffer_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Procfs read and write operations</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfs_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buffer, </span></span><br><span class="line"><span class="params">                           <span class="type">size_t</span> count, <span class="type">loff_t</span> *pos)</span> &#123;</span><br><span class="line">    <span class="comment">// Read implementation details</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfs_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer, </span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> count, <span class="type">loff_t</span> *pos)</span> &#123;</span><br><span class="line">    <span class="comment">// Write implementation details</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sysfs-Integration-Example"><a href="#Sysfs-Integration-Example" class="headerlink" title="Sysfs Integration Example"></a>Sysfs Integration Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">driver_kobject</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> driver_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sysfs show and store methods</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">driver_show</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, </span></span><br><span class="line"><span class="params">                           <span class="keyword">struct</span> kobj_attribute *attr, <span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d\n&quot;</span>, driver_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">driver_store</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, </span></span><br><span class="line"><span class="params">                            <span class="keyword">struct</span> kobj_attribute *attr, </span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count)</span> &#123;</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%d&quot;</span>, &amp;driver_value);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="User-Space-Interaction-Examples"><a href="#User-Space-Interaction-Examples" class="headerlink" title="User-Space Interaction Examples"></a>User-Space Interaction Examples</h3><h4 id="Procfs-Interaction-C-Program"><a href="#Procfs-Interaction-C-Program" class="headerlink" title="Procfs Interaction (C Program)"></a>Procfs Interaction (C Program)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROC_FILE <span class="string">&quot;/proc/driver_status&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Write to and read from procfs</span></span><br><span class="line">    fd = open(PROC_FILE, O_WRONLY);</span><br><span class="line">    write(fd, <span class="string">&quot;Hello from User Space&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    fd = open(PROC_FILE, O_RDONLY);</span><br><span class="line">    read(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read from procfs: %s\n&quot;</span>, buffer);</span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kernel-Filesystem-Interfaces"><a href="#Kernel-Filesystem-Interfaces" class="headerlink" title="Kernel Filesystem Interfaces"></a>Kernel Filesystem Interfaces</h2><h3 id="Procfs-proc"><a href="#Procfs-proc" class="headerlink" title="Procfs (&#x2F;proc)"></a>Procfs (&#x2F;proc)</h3><ul>
<li>Virtual filesystem providing kernel and process information</li>
<li>Allows runtime system information access</li>
<li>Primarily read-only kernel diagnostic interface</li>
</ul>
<h3 id="Sysfs-sys"><a href="#Sysfs-sys" class="headerlink" title="Sysfs (&#x2F;sys)"></a>Sysfs (&#x2F;sys)</h3><ul>
<li>Represents device, driver, and bus relationships</li>
<li>Provides unified device model representation</li>
<li>Enables dynamic device configuration</li>
<li>Supports runtime device attribute manipulation</li>
</ul>
<h2 id="Driver-Bus-Relationship"><a href="#Driver-Bus-Relationship" class="headerlink" title="Driver-Bus Relationship"></a>Driver-Bus Relationship</h2><p>The Linux device model establishes a sophisticated relationship between drivers, devices, and buses:</p>
<ul>
<li><strong>Bus</strong>: Represents a communication pathway</li>
<li><strong>Device</strong>: Physical or logical hardware component</li>
<li><strong>Driver</strong>: Software controlling device functionality</li>
</ul>
<p>Communication flow:</p>
<ol>
<li>Bus discovers devices</li>
<li>Driver matches with compatible devices</li>
<li>Kernel facilitates device-driver binding</li>
<li>Driver registers device-specific operations</li>
</ol>
<h2 id="Device-Driver-APIs-and-Interfaces"><a href="#Device-Driver-APIs-and-Interfaces" class="headerlink" title="Device Driver APIs and Interfaces"></a>Device Driver APIs and Interfaces</h2><p>Key Linux kernel APIs for device driver development:</p>
<ul>
<li><p><strong>Registration Mechanisms</strong></p>
<ul>
<li><code>register_chrdev()</code></li>
<li><code>register_netdev()</code></li>
<li><code>blk_mq_alloc_queue()</code></li>
</ul>
</li>
<li><p><strong>Synchronization Primitives</strong></p>
<ul>
<li>Spinlocks</li>
<li>Mutexes</li>
<li>Completion variables</li>
<li>Wait queues</li>
</ul>
</li>
<li><p><strong>Memory Management</strong></p>
<ul>
<li><code>kmalloc()</code> and <code>kfree()</code></li>
<li>DMA buffer allocation</li>
<li>Kernel memory mapping utilities</li>
</ul>
</li>
</ul>
<h2 id="Best-Practices-and-Recommendations"><a href="#Best-Practices-and-Recommendations" class="headerlink" title="Best Practices and Recommendations"></a>Best Practices and Recommendations</h2><ol>
<li><p><strong>Kernel Space Development</strong></p>
<ul>
<li>Minimize kernel space code complexity</li>
<li>Use appropriate synchronization mechanisms</li>
<li>Implement robust error handling</li>
<li>Follow kernel coding standards</li>
</ul>
</li>
<li><p><strong>Memory Management</strong></p>
<ul>
<li>Be cautious with dynamic memory allocation</li>
<li>Use appropriate memory barriers</li>
<li>Handle potential memory leaks</li>
</ul>
</li>
<li><p><strong>Performance Considerations</strong></p>
<ul>
<li>Optimize critical path operations</li>
<li>Minimize lock contention</li>
<li>Use efficient data structures</li>
</ul>
</li>
</ol>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Linux device drivers represent a sophisticated ecosystem of hardware abstraction, offering developers powerful tools for system-level programming. The intricate relationships between VFS, device drivers, and kernel subsystems provide a flexible and extensible framework for hardware interaction.</p>
<h2 id="Recommended-Learning-Path"><a href="#Recommended-Learning-Path" class="headerlink" title="Recommended Learning Path"></a>Recommended Learning Path</h2><ol>
<li>Study basic C programming</li>
<li>Learn kernel module development</li>
<li>Understand Linux kernel internals</li>
<li>Practice with simple device driver examples</li>
<li>Explore advanced driver development techniques</li>
</ol>
<p><strong>Note</strong>: Device driver development requires deep understanding of both software principles and hardware interactions. Continuous learning and practical experience are key to mastering this domain.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://apexpeng.github.io/2024/12/31/linux-devicedriver-intro/" data-id="cm5c7gmub000gdgvyagxc54kw" data-title="Linux Device Driver Introduction" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux-input-subsystem" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/31/linux-input-subsystem/" class="article-date">
  <time class="dt-published" datetime="2024-12-31T01:03:56.491Z" itemprop="datePublished">2024-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/31/linux-input-subsystem/">Exploring the Linux Input System: Events, Key Management, Touchscreens, and Sensor Integration</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>The Linux input subsystem is a robust framework for handling input devices such as keyboards, mice, touchscreens, and sensors. This article delves into the architecture and functionality of the Linux input system, covering events, key management, touchscreen handling, and sensor integration. We’ll also explore how Linux interfaces with hardware buses like I²C, SPI, and ADC&#x2F;DAC, complemented by reference code examples.</p>
<hr>
<h2 id="1-Understanding-the-Linux-Input-Event-System"><a href="#1-Understanding-the-Linux-Input-Event-System" class="headerlink" title="1. Understanding the Linux Input Event System"></a><strong>1. Understanding the Linux Input Event System</strong></h2><h3 id="What-Is-an-Event-in-Linux"><a href="#What-Is-an-Event-in-Linux" class="headerlink" title="What Is an Event in Linux?"></a>What Is an Event in Linux?</h3><p>An <strong>event</strong> in the Linux input system represents an input action. For example:</p>
<ul>
<li>A key press on a keyboard generates a <code>KEY_PRESS</code> event.</li>
<li>A touchscreen tap produces <code>ABS</code> (absolute position) events.</li>
<li>Sensor data updates trigger events for user-space applications.</li>
</ul>
<h3 id="How-Events-Are-Generated-and-Delivered"><a href="#How-Events-Are-Generated-and-Delivered" class="headerlink" title="How Events Are Generated and Delivered"></a>How Events Are Generated and Delivered</h3><p>The Linux kernel manages events using the <strong>event device interface</strong> (<code>/dev/input/eventX</code>). Events are represented as structures of type <code>input_event</code> in <code>linux/input.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span>  <span class="comment">// Timestamp</span></span><br><span class="line">    __u16 type;           <span class="comment">// Event type (e.g., EV_KEY, EV_ABS)</span></span><br><span class="line">    __u16 code;           <span class="comment">// Event code (specific key or axis)</span></span><br><span class="line">    __s32 value;          <span class="comment">// Event value (pressed/released or position)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>Event Generation</strong>  </p>
<ul>
<li>A driver populates an <code>input_event</code> structure and calls <code>input_event()</code> or <code>input_sync()</code> to propagate the event.</li>
<li>Example: A key press might call:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input_event(dev, EV_KEY, KEY_A, <span class="number">1</span>); <span class="comment">// Press &#x27;A&#x27;</span></span><br><span class="line">input_sync(dev);                   <span class="comment">// Sync the event</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Event Delivery</strong>  </p>
<ul>
<li>Events are written to <code>/dev/input/eventX</code> and can be read by user-space applications.</li>
<li>Use the <strong>evdev</strong> interface in user-space to read events.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-Linux-Key-Management-System"><a href="#2-Linux-Key-Management-System" class="headerlink" title="2. Linux Key Management System"></a><strong>2. Linux Key Management System</strong></h2><p>Linux manages keyboard input through the <strong>key management system</strong>, handling actions like key presses and releases. Keycodes are mapped to specific actions using <strong>keymaps</strong>.</p>
<h3 id="Implementing-Key-Events"><a href="#Implementing-Key-Events" class="headerlink" title="Implementing Key Events"></a>Implementing Key Events</h3><p>Example: A keyboard driver generating a key event:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">example_key_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span> &#123;</span><br><span class="line">    input_event(dev, EV_KEY, KEY_A, <span class="number">1</span>); <span class="comment">// Key A pressed</span></span><br><span class="line">    input_sync(dev);                   <span class="comment">// Synchronize event</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reading-Key-Events-in-User-Space"><a href="#Reading-Key-Events-in-User-Space" class="headerlink" title="Reading Key Events in User Space"></a>Reading Key Events in User Space</h3><p>In user space, use the <strong>evdev API</strong> to read key events:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/input/event0&quot;</span>, O_RDONLY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open event device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (read(fd, &amp;ev, <span class="keyword">sizeof</span>(ev)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Event type: %d, code: %d, value: %d\n&quot;</span>, ev.type, ev.code, ev.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-Touchscreen-Management-in-Linux"><a href="#3-Touchscreen-Management-in-Linux" class="headerlink" title="3. Touchscreen Management in Linux"></a><strong>3. Touchscreen Management in Linux</strong></h2><p>Touchscreens use the <strong>absolute position (EV_ABS)</strong> event type to report x&#x2F;y coordinates, pressure, and multitouch gestures.</p>
<h3 id="Handling-Touch-Events-in-a-Driver"><a href="#Handling-Touch-Events-in-a-Driver" class="headerlink" title="Handling Touch Events in a Driver"></a>Handling Touch Events in a Driver</h3><p>Touchscreen drivers report events using <code>EV_ABS</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">report_touch</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> pressure)</span> &#123;</span><br><span class="line">    input_event(dev, EV_ABS, ABS_X, x);</span><br><span class="line">    input_event(dev, EV_ABS, ABS_Y, y);</span><br><span class="line">    input_event(dev, EV_ABS, ABS_PRESSURE, pressure);</span><br><span class="line">    input_sync(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reading-Touch-Events"><a href="#Reading-Touch-Events" class="headerlink" title="Reading Touch Events"></a>Reading Touch Events</h3><p>Use <code>evdev</code> to capture touch events:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">ev</span>;</span></span><br><span class="line"><span class="keyword">while</span> (read(fd, &amp;ev, <span class="keyword">sizeof</span>(ev)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.type == EV_ABS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ABS event: code=%d, value=%d\n&quot;</span>, ev.code, ev.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-Sensor-Integration-in-Linux"><a href="#4-Sensor-Integration-in-Linux" class="headerlink" title="4. Sensor Integration in Linux"></a><strong>4. Sensor Integration in Linux</strong></h2><p>Sensors (e.g., temperature, accelerometers) often connect via I²C, SPI, or ADC&#x2F;DAC. Linux supports sensors through the <strong>Industrial I&#x2F;O (IIO)</strong> subsystem or custom drivers.</p>
<h3 id="I²C-Example-Reading-Sensor-Data"><a href="#I²C-Example-Reading-Sensor-Data" class="headerlink" title="I²C Example: Reading Sensor Data"></a>I²C Example: Reading Sensor Data</h3><p>An I²C-based driver might communicate with a temperature sensor:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_sensor</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span> &#123;</span><br><span class="line">    u8 buf[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = i2c_master_recv(client, buf, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> temp = (buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">1</span>]; <span class="comment">// Combine bytes</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SPI-Example-Writing-to-a-Sensor"><a href="#SPI-Example-Writing-to-a-Sensor" class="headerlink" title="SPI Example: Writing to a Sensor"></a>SPI Example: Writing to a Sensor</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_sensor</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, u8 reg, u8 value)</span> &#123;</span><br><span class="line">    u8 tx_buf[<span class="number">2</span>] = &#123; reg, value &#125;;</span><br><span class="line">    <span class="keyword">return</span> spi_write(spi, tx_buf, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ADC-DAC-for-Analog-Sensors"><a href="#ADC-DAC-for-Analog-Sensors" class="headerlink" title="ADC&#x2F;DAC for Analog Sensors"></a>ADC&#x2F;DAC for Analog Sensors</h3><p>For sensors with analog output, the kernel’s IIO subsystem handles ADC sampling. Configure the ADC driver to provide sensor values in <code>/sys/bus/iio</code>.</p>
<hr>
<h2 id="5-Using-Events-to-Manage-Sensors"><a href="#5-Using-Events-to-Manage-Sensors" class="headerlink" title="5. Using Events to Manage Sensors"></a><strong>5. Using Events to Manage Sensors</strong></h2><p>Sensors can trigger events when thresholds are exceeded, using the <code>input_event</code> API or dedicated mechanisms like GPIO interrupts.</p>
<h3 id="Example-Event-Based-Temperature-Alert"><a href="#Example-Event-Based-Temperature-Alert" class="headerlink" title="Example: Event-Based Temperature Alert"></a>Example: Event-Based Temperature Alert</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_temp_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">int</span> temp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (temp &gt; THRESHOLD) &#123;</span><br><span class="line">        input_event(dev, EV_MSC, MSC_SERIAL, temp); <span class="comment">// Report temperature</span></span><br><span class="line">        input_sync(dev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>User space can read and act on these events as described above.</p>
<hr>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h2><p>The Linux input system is highly versatile, enabling developers to handle various input sources, from traditional keyboards to advanced sensors. By leveraging the event-driven architecture, key management, and integration with buses like I²C and SPI, developers can create powerful, responsive applications. Whether you’re managing a touchscreen or an industrial sensor network, understanding these core concepts ensures seamless input handling in Linux systems. </p>
<p>For further exploration, consult the Linux kernel documentation and experiment with the provided code examples!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://apexpeng.github.io/2024/12/31/linux-input-subsystem/" data-id="cm5c7gmuc000hdgvy6odogmt0" data-title="Exploring the Linux Input System: Events, Key Management, Touchscreens, and Sensor Integration" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux-kernel-debug" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/31/linux-kernel-debug/" class="article-date">
  <time class="dt-published" datetime="2024-12-31T01:03:56.491Z" itemprop="datePublished">2024-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/31/linux-kernel-debug/">Debugging the Linux Kernel: A Comprehensive Guide</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Debugging the Linux kernel is a critical skill for developers working on kernel modules, drivers, or debugging complex system issues. This article explains how the kernel implements <code>printk</code>, the role of console drivers, and the relationship between <code>printk</code> and the Linux console. Additionally, we explore advanced debugging techniques, including storing kernel logs in RAM, enabling kernel hacking options, and using tools like <code>kgdb</code>, ftrace, and dynamic debugging.</p>
<hr>
<h2 id="Understanding-printk-in-Linux"><a href="#Understanding-printk-in-Linux" class="headerlink" title="Understanding printk in Linux"></a><strong>Understanding <code>printk</code> in Linux</strong></h2><h3 id="What-is-printk"><a href="#What-is-printk" class="headerlink" title="What is printk?"></a><strong>What is <code>printk</code>?</strong></h3><p><code>printk</code> is the primary logging function in the Linux kernel, similar to <code>printf</code> in user space. It provides a way to print messages from kernel space to the system log buffer.</p>
<h3 id="How-printk-Works"><a href="#How-printk-Works" class="headerlink" title="How printk Works"></a><strong>How <code>printk</code> Works</strong></h3><ol>
<li><p><strong>Ring Buffer</strong>: Kernel messages are stored in a circular ring buffer managed by the kernel log subsystem.</p>
<ul>
<li>The buffer is limited in size and overwrites old messages when full.</li>
<li>The buffer is exposed to user-space tools like <code>dmesg</code>.</li>
</ul>
</li>
<li><p><strong>Log Levels</strong>: <code>printk</code> supports log levels to categorize messages:</p>
<ul>
<li>Levels range from <code>KERN_EMERG</code> (critical) to <code>KERN_DEBUG</code> (debugging information).</li>
<li>Example: <code>printk(KERN_INFO &quot;Info message\n&quot;);</code>.</li>
</ul>
</li>
<li><p><strong>Console Handling</strong>: Messages in the ring buffer are sent to registered console drivers for output, such as the VGA console or serial console.</p>
</li>
</ol>
<h3 id="Example-Implementation-of-printk"><a href="#Example-Implementation-of-printk" class="headerlink" title="Example Implementation of printk"></a><strong>Example Implementation of <code>printk</code></strong></h3><p>When you invoke <code>printk</code>:</p>
<ul>
<li>The message is formatted and added to the kernel’s log buffer.</li>
<li>The kernel dispatches the message to all registered console drivers for output.</li>
</ul>
<hr>
<h2 id="Implementing-a-Linux-Console-Driver"><a href="#Implementing-a-Linux-Console-Driver" class="headerlink" title="Implementing a Linux Console Driver"></a><strong>Implementing a Linux Console Driver</strong></h2><p>A Linux console driver is responsible for displaying <code>printk</code> messages to a physical or virtual device, such as a screen or serial port.</p>
<h3 id="Structure-of-a-Console-Driver"><a href="#Structure-of-a-Console-Driver" class="headerlink" title="Structure of a Console Driver"></a><strong>Structure of a Console Driver</strong></h3><p>A typical console driver consists of:</p>
<ul>
<li><strong>Console Structure</strong>: Defines the driver properties.</li>
<li><strong>Console Operations</strong>: Provides methods like <code>write</code> to handle output.</li>
</ul>
<h3 id="Sample-Console-Driver-Skeleton"><a href="#Sample-Console-Driver-Skeleton" class="headerlink" title="Sample Console Driver Skeleton"></a><strong>Sample Console Driver Skeleton</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_console_write</span><span class="params">(<span class="keyword">struct</span> console *console, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Output the string to a custom device</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// Example: Output to a serial port</span></span><br><span class="line">        hardware_write(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">console</span> <span class="title">my_console</span> =</span> &#123;</span><br><span class="line">    .name   = <span class="string">&quot;my_console&quot;</span>,</span><br><span class="line">    .write  = my_console_write,</span><br><span class="line">    .flags  = CON_PRINTBUFFER,</span><br><span class="line">    .index  = <span class="number">-1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_console_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    register_console(&amp;my_console);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_console_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_console(&amp;my_console);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_console_init);</span><br><span class="line">module_exit(my_console_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Relationship-Between-printk-and-Console"><a href="#Relationship-Between-printk-and-Console" class="headerlink" title="Relationship Between printk and Console"></a><strong>Relationship Between <code>printk</code> and Console</strong></h3><ol>
<li><code>printk</code> writes messages to the kernel’s log buffer.</li>
<li>The kernel dispatches log messages to registered console drivers.</li>
<li>The console driver outputs messages to the appropriate device, such as a terminal or serial port.</li>
</ol>
<hr>
<h2 id="Storing-Kernel-Logs-dmesg-in-RAM"><a href="#Storing-Kernel-Logs-dmesg-in-RAM" class="headerlink" title="Storing Kernel Logs (dmesg) in RAM"></a><strong>Storing Kernel Logs (<code>dmesg</code>) in RAM</strong></h2><p>To store kernel messages in RAM:</p>
<ol>
<li><p><strong>Configure Kernel Options</strong>: Use the <code>CONFIG_PRINTK</code> and <code>CONFIG_LOG_BUF_SHIFT</code> options to adjust the size of the kernel log buffer.</p>
<ul>
<li>Example: <code>CONFIG_LOG_BUF_SHIFT=17</code> allocates a 128KB buffer.</li>
</ul>
</li>
<li><p><strong>Access Logs with <code>dmesg</code></strong>:</p>
<ul>
<li>Logs are exposed through <code>/dev/kmsg</code> or by the <code>dmesg</code> command.</li>
<li>To keep logs persistent, you can redirect them to a reserved memory region.</li>
</ul>
</li>
<li><p><strong>Persistent Kernel Logs</strong>:</p>
<ul>
<li>Use the <code>pstore</code> subsystem to save logs in NVRAM or another persistent storage medium for debugging after reboots.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="Advanced-Kernel-Debugging-Techniques"><a href="#Advanced-Kernel-Debugging-Techniques" class="headerlink" title="Advanced Kernel Debugging Techniques"></a><strong>Advanced Kernel Debugging Techniques</strong></h2><h3 id="1-Kernel-Hacking-Options"><a href="#1-Kernel-Hacking-Options" class="headerlink" title="1. Kernel Hacking Options"></a><strong>1. Kernel Hacking Options</strong></h3><p>Enable debugging features in the kernel:</p>
<ul>
<li><strong><code>CONFIG_DEBUG_KERNEL</code></strong>: Enables debugging features.</li>
<li><strong><code>CONFIG_KGDB</code></strong>: Adds support for kernel debugging with GDB.</li>
<li><strong><code>CONFIG_DEBUG_FS</code></strong>: Provides a filesystem for kernel debugging.</li>
</ul>
<h3 id="2-Kernel-Debugging-Tools"><a href="#2-Kernel-Debugging-Tools" class="headerlink" title="2. Kernel Debugging Tools"></a><strong>2. Kernel Debugging Tools</strong></h3><h4 id="kgdb-Kernel-GNU-Debugger"><a href="#kgdb-Kernel-GNU-Debugger" class="headerlink" title="kgdb (Kernel GNU Debugger)"></a><strong>kgdb (Kernel GNU Debugger)</strong></h4><p><code>kgdb</code> allows live debugging of the kernel using GDB. It works over serial or network connections.</p>
<ul>
<li><strong>Enable kgdb</strong>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KGDB=y</span><br><span class="line">CONFIG_KGDB_SERIAL_CONSOLE=y</span><br></pre></td></tr></table></figure></li>
<li><strong>Usage</strong>:<ol>
<li>Boot the kernel with <code>kgdbwait</code>.</li>
<li>Attach GDB to the kernel.</li>
</ol>
</li>
</ul>
<h4 id="ftrace"><a href="#ftrace" class="headerlink" title="ftrace"></a><strong>ftrace</strong></h4><p><code>ftrace</code> provides tracing capabilities for function calls, interrupts, and events in the kernel.</p>
<ul>
<li><strong>Enable ftrace</strong>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_FUNCTION_TRACER=y</span><br><span class="line">CONFIG_FUNCTION_GRAPH_TRACER=y</span><br></pre></td></tr></table></figure></li>
<li><strong>Usage</strong>:<ul>
<li>Enable tracing via <code>/sys/kernel/debug/tracing</code>.</li>
</ul>
</li>
</ul>
<h4 id="Dynamic-Debugging"><a href="#Dynamic-Debugging" class="headerlink" title="Dynamic Debugging"></a><strong>Dynamic Debugging</strong></h4><p>Allows adding debug statements dynamically without rebuilding the kernel.</p>
<ul>
<li><strong>Enable dynamic debugging</strong>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_DYNAMIC_DEBUG=y</span><br></pre></td></tr></table></figure></li>
<li><strong>Control debug logs</strong>:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;module my_module +p&quot; &gt; /sys/kernel/debug/dynamic_debug/control</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-Kprobes-and-eBPF"><a href="#3-Kprobes-and-eBPF" class="headerlink" title="3. Kprobes and eBPF"></a><strong>3. Kprobes and eBPF</strong></h3><h4 id="Kprobes-Instrument-specific-kernel-instructions-for-debugging"><a href="#Kprobes-Instrument-specific-kernel-instructions-for-debugging" class="headerlink" title="Kprobes: Instrument specific kernel instructions for debugging."></a><strong>Kprobes</strong>: Instrument specific kernel instructions for debugging.</h4><h4 id="eBPF-Attach-custom-programs-to-kernel-events-for-lightweight-and-flexible-tracing"><a href="#eBPF-Attach-custom-programs-to-kernel-events-for-lightweight-and-flexible-tracing" class="headerlink" title="eBPF: Attach custom programs to kernel events for lightweight and flexible tracing."></a><strong>eBPF</strong>: Attach custom programs to kernel events for lightweight and flexible tracing.</h4><h3 id="4-Kernel-Dump-Analysis"><a href="#4-Kernel-Dump-Analysis" class="headerlink" title="4. Kernel Dump Analysis"></a><strong>4. Kernel Dump Analysis</strong></h3><p>Use <code>kdump</code> to capture kernel memory during a crash for post-mortem analysis.</p>
<ul>
<li><strong>Enable kdump</strong>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KEXEC=y</span><br><span class="line">CONFIG_CRASH_DUMP=y</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h2><p>Debugging the Linux kernel involves understanding core mechanisms like <code>printk</code> and console drivers while leveraging advanced tools like <code>kgdb</code>, <code>ftrace</code>, and <code>kprobes</code>. By mastering these techniques, developers can efficiently diagnose and resolve kernel-level issues, ensuring system stability and performance.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://apexpeng.github.io/2024/12/31/linux-kernel-debug/" data-id="cm5c7gmuc000idgvycdy4867z" data-title="Debugging the Linux Kernel: A Comprehensive Guide" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux-network-intro" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/31/linux-network-intro/" class="article-date">
  <time class="dt-published" datetime="2024-12-31T01:03:56.491Z" itemprop="datePublished">2024-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/31/linux-network-intro/">Understanding Linux Network Architecture: OSI Model, TCP/IP Stack, and Implementation Details</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Linux’s networking subsystem is a robust and flexible implementation that supports various networking technologies, including Ethernet, Wi-Fi, Bluetooth, and cellular networks. This article explains how Linux aligns with networking models like the OSI and TCP&#x2F;IP, the role of netlink, and how low-level network device drivers integrate with the system. Additionally, we’ll explore how these technologies work together to provide seamless connectivity.</p>
<hr>
<h2 id="Linux-Networking-and-the-OSI-Model"><a href="#Linux-Networking-and-the-OSI-Model" class="headerlink" title="Linux Networking and the OSI Model"></a><strong>Linux Networking and the OSI Model</strong></h2><p>The OSI (Open Systems Interconnection) model divides network functionality into seven layers:</p>
<ol>
<li><strong>Physical Layer</strong>: Hardware connections like Ethernet cables and Wi-Fi radios.</li>
<li><strong>Data Link Layer</strong>: Protocols like Ethernet and 802.11 (Wi-Fi) manage access to the physical medium.</li>
<li><strong>Network Layer</strong>: Handles routing and forwarding (e.g., IP).</li>
<li><strong>Transport Layer</strong>: Provides reliable communication (TCP) or faster, connectionless services (UDP).</li>
<li><strong>Session Layer</strong>: Establishes and maintains connections.</li>
<li><strong>Presentation Layer</strong>: Translates data formats.</li>
<li><strong>Application Layer</strong>: Interacts with user applications (e.g., HTTP, FTP).</li>
</ol>
<p>While the OSI model is theoretical, Linux implements networking based on the practical <strong>TCP&#x2F;IP stack</strong>, which merges some layers for simplicity.</p>
<hr>
<h2 id="Linux-Networking-and-the-TCP-IP-Stack"><a href="#Linux-Networking-and-the-TCP-IP-Stack" class="headerlink" title="Linux Networking and the TCP&#x2F;IP Stack"></a><strong>Linux Networking and the TCP&#x2F;IP Stack</strong></h2><p>The TCP&#x2F;IP stack used in Linux has four layers:</p>
<ol>
<li><strong>Link Layer</strong>: Corresponds to the OSI Physical and Data Link layers.</li>
<li><strong>Network Layer</strong>: Manages IP and routing.</li>
<li><strong>Transport Layer</strong>: Implements protocols like TCP, UDP, and SCTP.</li>
<li><strong>Application Layer</strong>: Handles protocols like HTTP, DNS, and SMTP.</li>
</ol>
<h3 id="Linux-Source-Code-Examples"><a href="#Linux-Source-Code-Examples" class="headerlink" title="Linux Source Code Examples"></a><strong>Linux Source Code Examples</strong></h3><h4 id="Link-Layer-Network-Device-Driver"><a href="#Link-Layer-Network-Device-Driver" class="headerlink" title="Link Layer (Network Device Driver)"></a>Link Layer (Network Device Driver)</h4><p>Located in <code>/drivers/net/</code>. For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ethernet example (e1000_main.c)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">e1000_probe</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">const</span> <span class="keyword">struct</span> pci_device_id *ent)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span> =</span> alloc_etherdev(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> e1000_adapter));</span><br><span class="line">    pci_enable_device(pdev);</span><br><span class="line">    <span class="comment">// Other hardware initialization</span></span><br><span class="line">    <span class="keyword">return</span> register_netdev(netdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Network-Layer-IP-Routing"><a href="#Network-Layer-IP-Routing" class="headerlink" title="Network Layer (IP Routing)"></a>Network Layer (IP Routing)</h4><p>The routing implementation resides in <code>/net/ipv4/route.c</code>. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example: ip_forward()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_forward</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> =</span> ip_hdr(skb);</span><br><span class="line">    <span class="comment">// Check packet validity, route, and forward</span></span><br><span class="line">    <span class="keyword">return</span> dst_output(dev_net(skb-&gt;dev), skb-&gt;sk, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Transport-Layer-TCP-Implementation"><a href="#Transport-Layer-TCP-Implementation" class="headerlink" title="Transport Layer (TCP Implementation)"></a>Transport Layer (TCP Implementation)</h4><p>TCP is implemented in <code>/net/ipv4/tcp.c</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example: tcp_transmit_skb()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tcp_transmit_skb</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> rst)</span> &#123;</span><br><span class="line">    <span class="comment">// Prepare and send TCP packet</span></span><br><span class="line">    tcp_queue_skb(sk, skb);</span><br><span class="line">    ip_queue_xmit(skb, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Application-Layer"><a href="#Application-Layer" class="headerlink" title="Application Layer"></a>Application Layer</h4><p>Applications interact with the kernel through system calls like <code>socket()</code>. Example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">connect(sockfd, &amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">send(sockfd, data, len, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Netlink-Kernel-User-Communication"><a href="#Netlink-Kernel-User-Communication" class="headerlink" title="Netlink: Kernel-User Communication"></a><strong>Netlink: Kernel-User Communication</strong></h2><p>Netlink is a socket-based mechanism used to communicate between user space and kernel space for network configuration and management.</p>
<h3 id="Key-Features"><a href="#Key-Features" class="headerlink" title="Key Features"></a><strong>Key Features</strong></h3><ul>
<li>Configures routing, interfaces, and filters.</li>
<li>Notifies user space of events like link changes.</li>
</ul>
<h3 id="Netlink-Implementation"><a href="#Netlink-Implementation" class="headerlink" title="Netlink Implementation"></a><strong>Netlink Implementation</strong></h3><p>Netlink handlers are implemented in <code>/net/netlink/</code>.</p>
<h4 id="Example-Route-Addition-via-Netlink"><a href="#Example-Route-Addition-via-Netlink" class="headerlink" title="Example: Route Addition via Netlink"></a>Example: Route Addition via Netlink</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> nlmsg_put(skb, pid, seq, RTM_NEWROUTE, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rtmsg), <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtmsg</span> *<span class="title">rtm</span> =</span> nlmsg_data(nlh);</span><br><span class="line"><span class="comment">// Fill rtm fields</span></span><br><span class="line">netlink_unicast(sock, skb, pid, MSG_DONTWAIT);</span><br></pre></td></tr></table></figure>

<h3 id="User-Space-Example"><a href="#User-Space-Example" class="headerlink" title="User Space Example"></a><strong>User Space Example</strong></h3><p>Tools like <code>ip</code> (from <code>iproute2</code>) use netlink:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Low-Level-Linux-Network-Device-Drivers"><a href="#Low-Level-Linux-Network-Device-Drivers" class="headerlink" title="Low-Level Linux Network Device Drivers"></a><strong>Low-Level Linux Network Device Drivers</strong></h2><p>Network device drivers interface between hardware and the kernel, abstracting hardware details for the kernel networking stack.</p>
<h3 id="Key-Operations"><a href="#Key-Operations" class="headerlink" title="Key Operations"></a><strong>Key Operations</strong></h3><ol>
<li><p><strong>Initialization</strong>:</p>
<ul>
<li>Probed via bus-specific interfaces (PCI, USB, etc.).</li>
<li>Registers itself with the networking subsystem using <code>register_netdev()</code>.</li>
</ul>
</li>
<li><p><strong>Packet Transmission</strong>:</p>
<ul>
<li>Implements <code>ndo_start_xmit()</code> to handle outgoing packets.</li>
</ul>
</li>
<li><p><strong>Packet Reception</strong>:</p>
<ul>
<li>Triggers a hardware interrupt when packets arrive.</li>
<li>Uses <code>netif_rx()</code> or <code>napi_schedule()</code> to pass packets to the stack.</li>
</ul>
</li>
</ol>
<h3 id="Driver-Example-Ethernet"><a href="#Driver-Example-Ethernet" class="headerlink" title="Driver Example: Ethernet"></a><strong>Driver Example: Ethernet</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">netdev_tx_t</span> <span class="title function_">my_driver_start_xmit</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_driver_priv</span> *<span class="title">priv</span> =</span> netdev_priv(dev);</span><br><span class="line">    dma_map_single(&amp;priv-&gt;pdev-&gt;dev, skb-&gt;data, skb-&gt;len, DMA_TO_DEVICE);</span><br><span class="line">    netdev_tx_completed_queue(priv-&gt;tx_queue, <span class="number">1</span>, skb-&gt;len);</span><br><span class="line">    <span class="keyword">return</span> NETDEV_TX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Wireless-Networking-Wi-Fi-Bluetooth-and-Cellular"><a href="#Wireless-Networking-Wi-Fi-Bluetooth-and-Cellular" class="headerlink" title="Wireless Networking: Wi-Fi, Bluetooth, and Cellular"></a><strong>Wireless Networking: Wi-Fi, Bluetooth, and Cellular</strong></h2><h3 id="1-Wi-Fi"><a href="#1-Wi-Fi" class="headerlink" title="1. Wi-Fi"></a><strong>1. Wi-Fi</strong></h3><p>Wi-Fi is implemented via the mac80211 subsystem in <code>/net/mac80211/</code>. It provides a common interface for Wi-Fi drivers.</p>
<h4 id="Key-Components"><a href="#Key-Components" class="headerlink" title="Key Components"></a>Key Components</h4><ul>
<li><strong>Station Mode</strong>: Connects to access points.</li>
<li><strong>Access Point Mode</strong>: Acts as an AP for other devices.</li>
</ul>
<h4 id="Driver-Example-Wi-Fi-Device"><a href="#Driver-Example-Wi-Fi-Device" class="headerlink" title="Driver Example: Wi-Fi Device"></a>Driver Example: Wi-Fi Device</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_wifi_probe</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">const</span> <span class="keyword">struct</span> pci_device_id *id)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ieee80211_hw</span> *<span class="title">hw</span> =</span> ieee80211_alloc_hw(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> my_priv), &amp;my_ops);</span><br><span class="line">    pci_enable_device(pdev);</span><br><span class="line">    <span class="keyword">return</span> ieee80211_register_hw(hw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Bluetooth"><a href="#2-Bluetooth" class="headerlink" title="2. Bluetooth"></a><strong>2. Bluetooth</strong></h3><p>Linux Bluetooth stack includes:</p>
<ul>
<li><strong>HCI Layer</strong>: Interfaces with hardware.</li>
<li><strong>L2CAP Layer</strong>: Multiplexing protocol for higher layers.</li>
<li><strong>Profiles</strong>: Implement user-level services like A2DP.</li>
</ul>
<h4 id="Bluetooth-Initialization"><a href="#Bluetooth-Initialization" class="headerlink" title="Bluetooth Initialization"></a>Bluetooth Initialization</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hci_dev = hci_register_dev(hdev);</span><br><span class="line">hci_register_proto(&amp;my_proto);</span><br></pre></td></tr></table></figure>

<h3 id="3-Cellular-Modems"><a href="#3-Cellular-Modems" class="headerlink" title="3. Cellular (Modems)"></a><strong>3. Cellular (Modems)</strong></h3><p>Cellular network drivers communicate over USB or PCI. Implemented under <code>/drivers/net/usb/</code>.</p>
<hr>
<h2 id="Binding-Networking-Technologies-Together"><a href="#Binding-Networking-Technologies-Together" class="headerlink" title="Binding Networking Technologies Together"></a><strong>Binding Networking Technologies Together</strong></h2><p>Linux uses a unified approach for integrating diverse networking technologies:</p>
<ol>
<li><strong>Unified Sockets API</strong>: Applications use <code>socket()</code> regardless of the underlying transport (Ethernet, Wi-Fi, Bluetooth).</li>
<li><strong>Common Configuration Tools</strong>: Tools like <code>ifconfig</code>, <code>ip</code>, and <code>iw</code> configure all types of network interfaces.</li>
<li><strong>Dynamic Device Management</strong>:<ul>
<li>Interfaces are dynamically created for each technology.</li>
<li>Example: <code>wlan0</code> for Wi-Fi, <code>eth0</code> for Ethernet.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="How-Users-Can-Work-with-These-Technologies"><a href="#How-Users-Can-Work-with-These-Technologies" class="headerlink" title="How Users Can Work with These Technologies"></a><strong>How Users Can Work with These Technologies</strong></h2><h3 id="1-Ethernet"><a href="#1-Ethernet" class="headerlink" title="1. Ethernet"></a><strong>1. Ethernet</strong></h3><ul>
<li>Bring up an interface:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure></li>
<li>Debug with <code>ethtool</code>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool eth0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-Wi-Fi"><a href="#2-Wi-Fi" class="headerlink" title="2. Wi-Fi"></a><strong>2. Wi-Fi</strong></h3><ul>
<li>Scan for networks:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwlist wlan0 scan</span><br></pre></td></tr></table></figure></li>
<li>Connect to a network:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwconfig wlan0 essid <span class="string">&quot;MyNetwork&quot;</span> key s:password</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-Bluetooth"><a href="#3-Bluetooth" class="headerlink" title="3. Bluetooth"></a><strong>3. Bluetooth</strong></h3><ul>
<li>Pair with a device:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bluetoothctl</span><br></pre></td></tr></table></figure></li>
<li>Send a file:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obexctl send &lt;file&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-Cellular"><a href="#4-Cellular" class="headerlink" title="4. Cellular"></a><strong>4. Cellular</strong></h3><ul>
<li>Configure modem:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmcli -m 0 --simple-connect=<span class="string">&quot;apn=myapn&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h2><p>The Linux networking stack is a sophisticated system that integrates diverse technologies under a unified architecture. By understanding the OSI model, TCP&#x2F;IP stack, netlink, and network device drivers, developers can better harness Linux’s networking capabilities. Wireless technologies like Wi-Fi, Bluetooth, and cellular seamlessly coexist alongside Ethernet, making Linux a versatile platform for modern networking needs.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://apexpeng.github.io/2024/12/31/linux-network-intro/" data-id="cm5c7gmud000jdgvygpd23v5t" data-title="Understanding Linux Network Architecture: OSI Model, TCP/IP Stack, and Implementation Details" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux-pci-intro" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/31/linux-pci-intro/" class="article-date">
  <time class="dt-published" datetime="2024-12-31T01:03:56.491Z" itemprop="datePublished">2024-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/31/linux-pci-intro/">Understanding PCI in the Linux Kernel: Architecture, Registers, Speed, and Testing</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Peripheral Component Interconnect (PCI) is a standard interface for connecting peripherals to a computer’s motherboard. This article delves into how PCI works in the Linux kernel, covering its architecture, PCI speed, register descriptions, and practical methods for testing PCI devices and speed. We’ll also explore the use of huge pages with PCI for performance optimization.</p>
<hr>
<h2 id="PCI-Architecture"><a href="#PCI-Architecture" class="headerlink" title="PCI Architecture"></a><strong>PCI Architecture</strong></h2><p>The PCI subsystem in Linux enables communication between the CPU and connected devices. Key components include:</p>
<h3 id="1-PCI-Host-Bridge"><a href="#1-PCI-Host-Bridge" class="headerlink" title="1. PCI Host Bridge"></a><strong>1. PCI Host Bridge</strong></h3><ul>
<li>Connects the PCI bus to the CPU and memory.</li>
<li>Mediates transactions between PCI devices and system memory.</li>
</ul>
<h3 id="2-PCI-Bus"><a href="#2-PCI-Bus" class="headerlink" title="2. PCI Bus"></a><strong>2. PCI Bus</strong></h3><ul>
<li>A hierarchical structure with a root bus and optional subordinate buses.</li>
<li>Buses can contain multiple devices.</li>
</ul>
<h3 id="3-PCI-Devices"><a href="#3-PCI-Devices" class="headerlink" title="3. PCI Devices"></a><strong>3. PCI Devices</strong></h3><ul>
<li>Each device has up to 8 functions.</li>
<li>Functions are addressed by Bus, Device, and Function numbers (BDF).</li>
</ul>
<h3 id="4-PCI-Configuration-Space"><a href="#4-PCI-Configuration-Space" class="headerlink" title="4. PCI Configuration Space"></a><strong>4. PCI Configuration Space</strong></h3><ul>
<li>Each device&#x2F;function has a 256-byte configuration space (or 4 KB for PCIe).</li>
<li>Configuration registers control the device’s behavior.</li>
</ul>
<hr>
<h2 id="PCI-Speed-and-Generations"><a href="#PCI-Speed-and-Generations" class="headerlink" title="PCI Speed and Generations"></a><strong>PCI Speed and Generations</strong></h2><p>The PCI standard evolved to improve speed and bandwidth:</p>
<ul>
<li><strong>PCI</strong>: 133 MB&#x2F;s (32-bit, 33 MHz).</li>
<li><strong>PCI-X</strong>: Up to 4.3 GB&#x2F;s (64-bit, 533 MHz).</li>
<li><strong>PCIe</strong>: Scalable lanes (x1, x2, …, x16) with speeds like PCIe 4.0 (16 GT&#x2F;s per lane).</li>
</ul>
<hr>
<h2 id="PCI-Registers"><a href="#PCI-Registers" class="headerlink" title="PCI Registers"></a><strong>PCI Registers</strong></h2><p>PCI configuration space is divided into:</p>
<ol>
<li><p><strong>Standard Header (64 bytes)</strong>:</p>
<ul>
<li>Device and vendor identification.</li>
<li>Command and status registers.</li>
<li>Base Address Registers (BARs).</li>
</ul>
</li>
<li><p><strong>Device-Specific Area</strong>:</p>
<ul>
<li>Optional fields for additional capabilities.</li>
</ul>
</li>
</ol>
<h3 id="Key-Registers"><a href="#Key-Registers" class="headerlink" title="Key Registers"></a><strong>Key Registers</strong></h3><ul>
<li><strong>Vendor ID and Device ID</strong>:<ul>
<li>Identifies the device.</li>
<li>Offset: 0x00.</li>
</ul>
</li>
<li><strong>Command Register</strong>:<ul>
<li>Controls device state (e.g., enabling&#x2F;disabling memory or I&#x2F;O access).</li>
<li>Offset: 0x04.</li>
</ul>
</li>
<li><strong>BARs</strong>:<ul>
<li>Map device memory or I&#x2F;O regions into system space.</li>
<li>Offset: 0x10–0x24.</li>
</ul>
</li>
</ul>
<h3 id="Reading-PCI-Registers-in-Linux"><a href="#Reading-PCI-Registers-in-Linux" class="headerlink" title="Reading PCI Registers in Linux"></a><strong>Reading PCI Registers in Linux</strong></h3><p>You can read PCI configuration space using <code>lspci</code> or <code>setpci</code>.</p>
<p>Example:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -v</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Testing-PCI-Speed"><a href="#Testing-PCI-Speed" class="headerlink" title="Testing PCI Speed"></a><strong>Testing PCI Speed</strong></h2><p>PCI speed tests typically involve measuring bandwidth and latency. Tools and techniques include:</p>
<h3 id="1-Benchmark-Tools"><a href="#1-Benchmark-Tools" class="headerlink" title="1. Benchmark Tools"></a><strong>1. Benchmark Tools</strong></h3><ul>
<li><strong><code>lspci</code></strong>: Displays PCI device information.</li>
<li><strong><code>dd</code></strong>: Measures read&#x2F;write speed on PCI storage devices.</li>
<li><strong>Custom Programs</strong>: Use tools like <code>iperf</code> for networking cards.</li>
</ul>
<p>Example: Testing PCIe bandwidth:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/nvme0n1 of=/dev/null bs=1M count=1000</span><br></pre></td></tr></table></figure>

<h3 id="2-Using-Kernel-Drivers"><a href="#2-Using-Kernel-Drivers" class="headerlink" title="2. Using Kernel Drivers"></a><strong>2. Using Kernel Drivers</strong></h3><ul>
<li>Write a kernel module to measure read&#x2F;write latency on PCI devices.</li>
<li>Use <code>ioremap()</code> to map BAR memory and measure data access speed.</li>
</ul>
<hr>
<h2 id="Testing-PCI-Devices"><a href="#Testing-PCI-Devices" class="headerlink" title="Testing PCI Devices"></a><strong>Testing PCI Devices</strong></h2><h3 id="1-Using-lspci"><a href="#1-Using-lspci" class="headerlink" title="1. Using lspci"></a><strong>1. Using <code>lspci</code></strong></h3><p><code>lspci</code> lists all PCI devices and their configurations:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -v</span><br></pre></td></tr></table></figure>

<h3 id="2-Using-sysfs"><a href="#2-Using-sysfs" class="headerlink" title="2. Using sysfs"></a><strong>2. Using <code>sysfs</code></strong></h3><p>Inspect PCI devices through <code>/sys/bus/pci/devices</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sys/bus/pci/devices/0000\:00\:1f.2</span><br><span class="line"><span class="built_in">cat</span> vendor</span><br><span class="line"><span class="built_in">cat</span> device</span><br></pre></td></tr></table></figure>

<h3 id="3-Using-Debugfs"><a href="#3-Using-Debugfs" class="headerlink" title="3. Using Debugfs"></a><strong>3. Using Debugfs</strong></h3><p>Debugfs provides low-level access to PCI registers:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line"><span class="built_in">cat</span> /sys/kernel/debug/pci/0000:00:1f.2/config</span><br></pre></td></tr></table></figure>

<h3 id="4-Writing-a-Simple-Driver"><a href="#4-Writing-a-Simple-Driver" class="headerlink" title="4. Writing a Simple Driver"></a><strong>4. Writing a Simple Driver</strong></h3><p>Create a kernel module to probe a PCI device, map its BAR, and interact with it.</p>
<p>Example: Simple PCI driver skeleton:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pci.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pci_probe</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">const</span> <span class="keyword">struct</span> pci_device_id *id)</span> &#123;</span><br><span class="line">    <span class="type">void</span> __iomem *bar;</span><br><span class="line">    pci_enable_device(pdev);</span><br><span class="line">    bar = pci_iomap(pdev, <span class="number">0</span>, pci_resource_len(pdev, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (!bar)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interact with the device memory</span></span><br><span class="line">    iowrite32(<span class="number">0x1</span>, bar);</span><br><span class="line">    pci_iounmap(pdev, bar);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_remove</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev)</span> &#123;</span><br><span class="line">    pci_disable_device(pdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_device_id</span> <span class="title">pci_ids</span>[] =</span> &#123;</span><br><span class="line">    &#123; PCI_DEVICE(<span class="number">0x1234</span>, <span class="number">0x5678</span>), &#125;, <span class="comment">// Replace with your vendor/device IDs</span></span><br><span class="line">    &#123; <span class="number">0</span>, &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">pci_driver</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_pci_driver&quot;</span>,</span><br><span class="line">    .id_table = pci_ids,</span><br><span class="line">    .probe = pci_probe,</span><br><span class="line">    .remove = pci_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_pci_driver(pci_driver);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Using-Huge-Pages-with-PCI-Devices"><a href="#Using-Huge-Pages-with-PCI-Devices" class="headerlink" title="Using Huge Pages with PCI Devices"></a><strong>Using Huge Pages with PCI Devices</strong></h2><h3 id="Why-Use-Huge-Pages"><a href="#Why-Use-Huge-Pages" class="headerlink" title="Why Use Huge Pages?"></a><strong>Why Use Huge Pages?</strong></h3><ul>
<li>Reduces TLB (Translation Lookaside Buffer) misses.</li>
<li>Improves performance for PCI devices requiring large memory regions (e.g., GPUs, NICs).</li>
</ul>
<h3 id="Steps-to-Enable-Huge-Pages"><a href="#Steps-to-Enable-Huge-Pages" class="headerlink" title="Steps to Enable Huge Pages"></a><strong>Steps to Enable Huge Pages</strong></h3><ol>
<li><p><strong>Reserve Huge Pages</strong>:</p>
<ul>
<li>Set the number of huge pages:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 128 &gt; /proc/sys/vm/nr_hugepages</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Allocate Huge Pages</strong>:</p>
<ul>
<li>Use <code>mmap()</code> in userspace to allocate huge pages for DMA buffers.</li>
</ul>
</li>
<li><p><strong>Modify PCI Driver</strong>:</p>
<ul>
<li>Use <code>dma_map_page()</code> or <code>dma_map_single()</code> for DMA transfers.</li>
<li>Ensure physical memory alignment to huge page boundaries.</li>
</ul>
</li>
</ol>
<h3 id="Example-Allocating-Huge-Pages-for-DMA"><a href="#Example-Allocating-Huge-Pages-for-DMA" class="headerlink" title="Example: Allocating Huge Pages for DMA"></a><strong>Example: Allocating Huge Pages for DMA</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/dma-mapping.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *dma_buffer = dma_alloc_coherent(&amp;pdev-&gt;dev, SZ_2M, &amp;dma_handle, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!dma_buffer)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use dma_buffer for PCI device communication</span></span><br><span class="line">dma_free_coherent(&amp;pdev-&gt;dev, SZ_2M, dma_buffer, dma_handle);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><strong>Summary</strong></h2><h3 id="1-How-PCI-Works-in-Linux"><a href="#1-How-PCI-Works-in-Linux" class="headerlink" title="1. How PCI Works in Linux"></a><strong>1. How PCI Works in Linux</strong></h3><ul>
<li>Hierarchical structure with host bridge, buses, and devices.</li>
<li>Kernel interfaces like <code>lspci</code>, <code>sysfs</code>, and <code>debugfs</code> expose device details.</li>
</ul>
<h3 id="2-PCI-Configuration-and-Speed"><a href="#2-PCI-Configuration-and-Speed" class="headerlink" title="2. PCI Configuration and Speed"></a><strong>2. PCI Configuration and Speed</strong></h3><ul>
<li>Configuration space provides device control and status information.</li>
<li>PCI speed varies by standard and lane configuration (e.g., PCIe 4.0).</li>
</ul>
<h3 id="3-PCI-Testing"><a href="#3-PCI-Testing" class="headerlink" title="3. PCI Testing"></a><strong>3. PCI Testing</strong></h3><ul>
<li>Use tools (<code>lspci</code>, <code>dd</code>) and custom drivers to benchmark and debug devices.</li>
</ul>
<h3 id="4-PCI-and-Huge-Pages"><a href="#4-PCI-and-Huge-Pages" class="headerlink" title="4. PCI and Huge Pages"></a><strong>4. PCI and Huge Pages</strong></h3><ul>
<li>Huge pages optimize memory access for PCI devices requiring large DMA regions.</li>
</ul>
<p>Understanding the Linux PCI subsystem equips developers with the knowledge to debug, optimize, and extend PCI device support. From hardware diagnostics to performance tuning, the subsystem offers robust tools and APIs for modern computing needs.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://apexpeng.github.io/2024/12/31/linux-pci-intro/" data-id="cm5c7gmue000kdgvyf30madxe" data-title="Understanding PCI in the Linux Kernel: Architecture, Registers, Speed, and Testing" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux-usb-intro" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/31/linux-usb-intro/" class="article-date">
  <time class="dt-published" datetime="2024-12-31T01:03:56.491Z" itemprop="datePublished">2024-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/31/linux-usb-intro/">Deep Dive Into the Linux USB Subsystem: Implementation and Usage</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>This article examines the Linux USB subsystem in detail, including its architecture, how USB devices are initialized, USB bus operations, OTG functionality, and implementation of USB device drivers. Additionally, we’ll discuss how users can interact with these devices and test them.</p>
<hr>
<h2 id="How-USB-Works-in-Linux"><a href="#How-USB-Works-in-Linux" class="headerlink" title="How USB Works in Linux"></a><strong>How USB Works in Linux</strong></h2><p>The Linux USB subsystem operates as a layered architecture, enabling seamless communication between hardware and software. Here’s how it works:</p>
<h3 id="Steps-Involved"><a href="#Steps-Involved" class="headerlink" title="Steps Involved"></a><strong>Steps Involved</strong></h3><ol>
<li><p><strong>Device Detection</strong>:</p>
<ul>
<li>When a USB device is plugged in, the host controller detects it and triggers an interrupt.</li>
<li>The kernel identifies the new device through a signal on the USB bus.</li>
</ul>
</li>
<li><p><strong>Device Enumeration</strong>:</p>
<ul>
<li>The kernel queries the device descriptors (e.g., Vendor ID, Product ID, and Device Class) using control transfers.</li>
<li>Descriptors are stored in kernel data structures.</li>
</ul>
</li>
<li><p><strong>Driver Binding</strong>:</p>
<ul>
<li>The USB core matches the device with a driver based on its descriptors.</li>
<li>A driver is loaded, and the device is made accessible to userspace.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="USB-Bus-Startup"><a href="#USB-Bus-Startup" class="headerlink" title="USB Bus Startup"></a><strong>USB Bus Startup</strong></h2><p>The USB bus starts when the host controller (e.g., EHCI, XHCI) is initialized. Host controller drivers (HCD) manage communication with USB devices.</p>
<h3 id="Key-Steps-in-USB-Bus-Startup"><a href="#Key-Steps-in-USB-Bus-Startup" class="headerlink" title="Key Steps in USB Bus Startup"></a><strong>Key Steps in USB Bus Startup</strong></h3><ol>
<li><p><strong>Initialization</strong>:</p>
<ul>
<li>HCD initializes the USB controller hardware.</li>
<li>Example: EHCI driver (<code>drivers/usb/host/ehci-hcd.c</code>).</li>
</ul>
</li>
<li><p><strong>Root Hub Setup</strong>:</p>
<ul>
<li>The host controller initializes the root hub, the logical connection point for devices.</li>
</ul>
</li>
<li><p><strong>Periodic Polling</strong>:</p>
<ul>
<li>USB hubs periodically poll for connected devices using hub events.</li>
</ul>
</li>
</ol>
<h3 id="Relevant-Code-Host-Controller-Initialization"><a href="#Relevant-Code-Host-Controller-Initialization" class="headerlink" title="Relevant Code: Host Controller Initialization"></a><strong>Relevant Code: Host Controller Initialization</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ehci_hcd_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_hcd</span> *<span class="title">hcd</span> =</span> usb_create_hcd(&amp;ehci_hc_driver, dev, <span class="string">&quot;ehci&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hcd)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> usb_add_hcd(hcd, irq, IRQF_SHARED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="User-Interaction"><a href="#User-Interaction" class="headerlink" title="User Interaction"></a><strong>User Interaction</strong></h3><ul>
<li>Devices are automatically registered in <code>/sys/bus/usb/devices/</code>.</li>
<li>Users can list devices with:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="USB-Architecture"><a href="#USB-Architecture" class="headerlink" title="USB Architecture"></a><strong>USB Architecture</strong></h2><p>The Linux USB architecture is modular, comprising several layers:</p>
<h3 id="1-Host-Controller-Driver-HCD"><a href="#1-Host-Controller-Driver-HCD" class="headerlink" title="1. Host Controller Driver (HCD)"></a><strong>1. Host Controller Driver (HCD)</strong></h3><p>Manages hardware-specific operations. Examples: EHCI, XHCI, and OHCI drivers.</p>
<ul>
<li><strong>Example</strong>: EHCI Driver (<code>drivers/usb/host/ehci-hcd.c</code>).</li>
<li>Responsibilities:<ul>
<li>Initialize USB hardware.</li>
<li>Schedule and execute data transfers.</li>
</ul>
</li>
</ul>
<h3 id="2-USB-Core"><a href="#2-USB-Core" class="headerlink" title="2. USB Core"></a><strong>2. USB Core</strong></h3><p>Manages:</p>
<ul>
<li>Device enumeration.</li>
<li>Power management.</li>
<li>Driver binding.</li>
</ul>
<p>Located in <code>/drivers/usb/core/</code>.</p>
<h3 id="3-USB-Class-Drivers"><a href="#3-USB-Class-Drivers" class="headerlink" title="3. USB Class Drivers"></a><strong>3. USB Class Drivers</strong></h3><p>Handle specific device types, such as keyboards, modems, and mass storage.</p>
<hr>
<h2 id="USB-OTG-On-The-Go"><a href="#USB-OTG-On-The-Go" class="headerlink" title="USB OTG (On-The-Go)"></a><strong>USB OTG (On-The-Go)</strong></h2><p>USB OTG allows devices to act as either a host or a peripheral. This is useful in embedded systems and mobile devices.</p>
<h3 id="OTG-Architecture"><a href="#OTG-Architecture" class="headerlink" title="OTG Architecture"></a><strong>OTG Architecture</strong></h3><ol>
<li><strong>Dual Role Devices</strong>: Devices that can switch roles between host and peripheral.</li>
<li><strong>OTG Controller</strong>: Manages role switching.</li>
</ol>
<h3 id="Implementation-OTG-Role-Switching"><a href="#Implementation-OTG-Role-Switching" class="headerlink" title="Implementation: OTG Role Switching"></a><strong>Implementation: OTG Role Switching</strong></h3><p>Located in <code>/drivers/usb/otg/</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">usb_gadget_probe_driver</span><span class="params">(<span class="keyword">struct</span> usb_gadget_driver *driver)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_gadget</span> *<span class="title">gadget</span> =</span> driver-&gt;gadget;</span><br><span class="line">    <span class="keyword">return</span> gadget-&gt;ops-&gt;start(gadget, driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="User-Interaction-1"><a href="#User-Interaction-1" class="headerlink" title="User Interaction"></a><strong>User Interaction</strong></h3><p>Users can enable OTG features through <code>sysfs</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;host&quot;</span> &gt; /sys/class/usb_role_switch/usb_role</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="USB-Hub-Device-Driver"><a href="#USB-Hub-Device-Driver" class="headerlink" title="USB Hub Device Driver"></a><strong>USB Hub Device Driver</strong></h2><p>USB hubs allow multiple devices to connect to a single USB port. The Linux USB hub driver handles device enumeration and power management.</p>
<h3 id="Key-Functions-in-the-Hub-Driver"><a href="#Key-Functions-in-the-Hub-Driver" class="headerlink" title="Key Functions in the Hub Driver"></a><strong>Key Functions in the Hub Driver</strong></h3><ol>
<li><p><strong>Initialization</strong>:</p>
<ul>
<li>Probes hub hardware and configures it.</li>
<li>Example: <code>usb_hub_probe()</code> in <code>drivers/usb/core/hub.c</code>.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">usb_hub_probe</span><span class="params">(<span class="keyword">struct</span> usb_interface *intf, <span class="type">const</span> <span class="keyword">struct</span> usb_device_id *id)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_hub</span> *<span class="title">hub</span> =</span> kzalloc(<span class="keyword">sizeof</span>(*hub), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">return</span> hub_configure(hub, intf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Device Enumeration</strong>:</p>
<ul>
<li>Detects new devices and handles their descriptors.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hub_event</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_hub</span> *<span class="title">hub</span> =</span> container_of(work, <span class="keyword">struct</span> usb_hub, hub_event);</span><br><span class="line">    hub_port_connect_change(hub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="User-Interaction-2"><a href="#User-Interaction-2" class="headerlink" title="User Interaction"></a><strong>User Interaction</strong></h3><p>Users can query connected hubs:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb -t</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="USB-Device-Driver-Implementations"><a href="#USB-Device-Driver-Implementations" class="headerlink" title="USB Device Driver Implementations"></a><strong>USB Device Driver Implementations</strong></h2><h3 id="1-USB-Modem"><a href="#1-USB-Modem" class="headerlink" title="1. USB Modem"></a><strong>1. USB Modem</strong></h3><p>The <code>cdc-acm</code> driver supports USB modems and is located at <code>drivers/usb/class/cdc-acm.c</code>.</p>
<h4 id="Key-Code-Modem-Driver-Initialization"><a href="#Key-Code-Modem-Driver-Initialization" class="headerlink" title="Key Code: Modem Driver Initialization"></a><strong>Key Code: Modem Driver Initialization</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdc_acm_probe</span><span class="params">(<span class="keyword">struct</span> usb_interface *intf, <span class="type">const</span> <span class="keyword">struct</span> usb_device_id *id)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdc_acm</span> *<span class="title">acm</span> =</span> kzalloc(<span class="keyword">sizeof</span>(*acm), GFP_KERNEL);</span><br><span class="line">    usb_set_intfdata(intf, acm);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="User-Interaction-3"><a href="#User-Interaction-3" class="headerlink" title="User Interaction"></a><strong>User Interaction</strong></h4><ul>
<li>Modems are accessible as <code>/dev/ttyUSB*</code>.</li>
<li>Use tools like <code>minicom</code> for testing:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minicom -D /dev/ttyUSB0</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-USB-Keyboard"><a href="#2-USB-Keyboard" class="headerlink" title="2. USB Keyboard"></a><strong>2. USB Keyboard</strong></h3><p>The <code>usbhid</code> driver handles USB keyboards (<code>drivers/hid/usbhid/</code>).</p>
<h4 id="Key-Code-HID-Device-Probe"><a href="#Key-Code-HID-Device-Probe" class="headerlink" title="Key Code: HID Device Probe"></a><strong>Key Code: HID Device Probe</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">usbhid_probe</span><span class="params">(<span class="keyword">struct</span> usb_interface *intf, <span class="type">const</span> <span class="keyword">struct</span> usb_device_id *id)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_hid</span> *<span class="title">uhid</span> =</span> kzalloc(<span class="keyword">sizeof</span>(*uhid), GFP_KERNEL);</span><br><span class="line">    usb_set_intfdata(intf, uhid);</span><br><span class="line">    <span class="keyword">return</span> hid_add_device(uhid-&gt;hid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="User-Interaction-4"><a href="#User-Interaction-4" class="headerlink" title="User Interaction"></a><strong>User Interaction</strong></h4><ul>
<li>Keyboards work with input subsystems (<code>/dev/input/</code>).</li>
<li>Use <code>evtest</code> to monitor input events:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install evtest</span><br><span class="line">evtest /dev/input/eventX</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-USB-HCI-Host-Controller-Interface"><a href="#3-USB-HCI-Host-Controller-Interface" class="headerlink" title="3. USB HCI (Host Controller Interface)"></a><strong>3. USB HCI (Host Controller Interface)</strong></h3><p>HCI drivers handle hardware-level USB communication.</p>
<h4 id="Key-Code-HCI-Initialization"><a href="#Key-Code-HCI-Initialization" class="headerlink" title="Key Code: HCI Initialization"></a><strong>Key Code: HCI Initialization</strong></h4><p>Example: XHCI driver (<code>drivers/usb/host/xhci.c</code>).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">xhci_hcd_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_hcd</span> *<span class="title">hcd</span> =</span> usb_create_hcd(&amp;xhci_hc_driver, dev, <span class="string">&quot;xhci&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> usb_add_hcd(hcd, irq, IRQF_SHARED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="User-Space-Testing-of-USB-Devices"><a href="#User-Space-Testing-of-USB-Devices" class="headerlink" title="User-Space Testing of USB Devices"></a><strong>User-Space Testing of USB Devices</strong></h2><h3 id="Using-lsusb"><a href="#Using-lsusb" class="headerlink" title="Using lsusb"></a><strong>Using <code>lsusb</code></strong></h3><ol>
<li>List USB devices:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure></li>
<li>View device hierarchy:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb -t</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Using-sysfs"><a href="#Using-sysfs" class="headerlink" title="Using sysfs"></a><strong>Using <code>sysfs</code></strong></h3><p>Inspect devices:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/bus/usb/devices/1-1/idVendor</span><br><span class="line"><span class="built_in">cat</span> /sys/bus/usb/devices/1-1/idProduct</span><br></pre></td></tr></table></figure>

<h3 id="USB-Debugging"><a href="#USB-Debugging" class="headerlink" title="USB Debugging"></a><strong>USB Debugging</strong></h3><p>Enable verbose logging:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1&quot;</span> &gt; /sys/module/usbcore/parameters/debug</span><br><span class="line">dmesg | grep usb</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h2><p>The Linux USB subsystem efficiently handles diverse USB devices with a layered architecture and a robust driver framework. From USB hubs to OTG and device-specific drivers, Linux ensures seamless communication between hardware and software. Understanding its internals allows developers to debug, test, and enhance USB device support.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://apexpeng.github.io/2024/12/31/linux-usb-intro/" data-id="cm5c7gmue000ldgvyast1ad24" data-title="Deep Dive Into the Linux USB Subsystem: Implementation and Usage" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux-userspace-debug" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/31/linux-userspace-debug/" class="article-date">
  <time class="dt-published" datetime="2024-12-31T01:03:56.491Z" itemprop="datePublished">2024-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/31/linux-userspace-debug/">Testing Linux I2C, USB, and PCI Drivers Using Userspace Tools and `Sysfs`</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Linux provides robust mechanisms for interacting with devices via <code>sysfs</code>. This allows developers to query and manipulate kernel objects from user space. Tools like <code>lsusb</code>, <code>lsi2c</code>, and <code>lspci</code> offer easy ways to test USB, I2C, and PCI devices. This article explains how to use these tools, highlights their underlying mechanisms, and provides practical steps to test Linux drivers.</p>
<hr>
<h2 id="Understanding-sysfs"><a href="#Understanding-sysfs" class="headerlink" title="Understanding sysfs"></a><strong>Understanding <code>sysfs</code></strong></h2><p><code>sysfs</code> is a virtual filesystem used to expose kernel and device attributes to user space. It allows users to access hardware details directly.</p>
<p>Key directories include:</p>
<ul>
<li><strong><code>/sys/class/</code></strong>: Lists device classes like <code>usb</code>, <code>i2c-dev</code>, and <code>pci</code>.</li>
<li><strong><code>/sys/devices/</code></strong>: Provides a hierarchical view of devices.</li>
<li><strong><code>/sys/bus/</code></strong>: Groups devices and drivers by their bus types (e.g., <code>usb</code>, <code>i2c</code>, <code>pci</code>).</li>
</ul>
<h3 id="Common-Commands"><a href="#Common-Commands" class="headerlink" title="Common Commands"></a><strong>Common Commands</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /sys/bus/usb/devices/    <span class="comment"># List USB devices</span></span><br><span class="line"><span class="built_in">ls</span> /sys/bus/i2c/devices/    <span class="comment"># List I2C devices</span></span><br><span class="line"><span class="built_in">ls</span> /sys/bus/pci/devices/    <span class="comment"># List PCI devices</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Testing-USB-Drivers-with-lsusb"><a href="#Testing-USB-Drivers-with-lsusb" class="headerlink" title="Testing USB Drivers with lsusb"></a><strong>Testing USB Drivers with <code>lsusb</code></strong></h2><p><code>lsusb</code> is a user-space tool for listing USB devices. It retrieves device descriptors, vendor IDs, and product IDs using <code>sysfs</code> and <code>/proc</code>.</p>
<h3 id="How-lsusb-Works"><a href="#How-lsusb-Works" class="headerlink" title="How lsusb Works"></a><strong>How <code>lsusb</code> Works</strong></h3><p>The source code of <code>lsusb</code> interacts with USB devices via <code>libusb</code>. Here’s a simplified excerpt from the <a target="_blank" rel="noopener" href="https://github.com/gregkh/usbutils/blob/master/lsusb.c">source code</a>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libusb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    libusb_context *ctx;</span><br><span class="line">    libusb_device **<span class="built_in">list</span>;</span><br><span class="line">    <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">    libusb_init(&amp;ctx);</span><br><span class="line">    count = libusb_get_device_list(ctx, &amp;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ssize_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">libusb_device_descriptor</span> <span class="title">desc</span>;</span></span><br><span class="line">        libusb_get_device_descriptor(<span class="built_in">list</span>[i], &amp;desc);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Vendor: %04x, Product: %04x\n&quot;</span>, desc.idVendor, desc.idProduct);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    libusb_free_device_list(<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">    libusb_exit(ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Installing-and-Running-lsusb"><a href="#Installing-and-Running-lsusb" class="headerlink" title="Installing and Running lsusb"></a><strong>Installing and Running <code>lsusb</code></strong></h3><ol>
<li>Install <code>lsusb</code>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install usbutils</span><br></pre></td></tr></table></figure></li>
<li>Run <code>lsusb</code> to list connected USB devices:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="Testing-I2C-Drivers-with-lsi2c"><a href="#Testing-I2C-Drivers-with-lsi2c" class="headerlink" title="Testing I2C Drivers with lsi2c"></a><strong>Testing I2C Drivers with <code>lsi2c</code></strong></h2><p><code>lsi2c</code> is a user-space tool for detecting and interacting with I2C devices. It communicates with devices using the <code>/dev/i2c-*</code> interface provided by the <code>i2c-dev</code> kernel module.</p>
<h3 id="How-lsi2c-Works"><a href="#How-lsi2c-Works" class="headerlink" title="How lsi2c Works"></a><strong>How <code>lsi2c</code> Works</strong></h3><p>The tool reads and writes I2C registers using the <code>ioctl</code> system call. Below is a simplified excerpt from the <a target="_blank" rel="noopener" href="https://github.com/costad2/i2cdev">source code</a>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c-dev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> file = open(<span class="string">&quot;/dev/i2c-1&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> addr = <span class="number">0x48</span>;</span><br><span class="line"></span><br><span class="line">    ioctl(file, I2C_SLAVE, addr);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(file, buf, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data: 0x%x\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">    close(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Installing-and-Running-lsi2c"><a href="#Installing-and-Running-lsi2c" class="headerlink" title="Installing and Running lsi2c"></a><strong>Installing and Running <code>lsi2c</code></strong></h3><ol>
<li>Clone the repository:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/costad2/i2cdev.git</span><br><span class="line"><span class="built_in">cd</span> i2cdev</span><br></pre></td></tr></table></figure></li>
<li>Build and run:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">./lsi2c</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="Testing-PCI-Drivers-with-lspci"><a href="#Testing-PCI-Drivers-with-lspci" class="headerlink" title="Testing PCI Drivers with lspci"></a><strong>Testing PCI Drivers with <code>lspci</code></strong></h2><p><code>lspci</code> is a user-space tool for listing PCI devices and querying their details. It uses the <code>/sys/bus/pci/devices/</code> directory and the <code>/proc/bus/pci</code> filesystem.</p>
<h3 id="How-lspci-Works"><a href="#How-lspci-Works" class="headerlink" title="How lspci Works"></a><strong>How <code>lspci</code> Works</strong></h3><p>The <a target="_blank" rel="noopener" href="https://github.com/pciutils/pciutils/blob/master/lspci.c">source code</a> interacts with PCI configuration space and device information files. Here’s a simplified example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pci/pci.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_access</span> *<span class="title">pacc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="type">char</span> namebuf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    pacc = pci_alloc();</span><br><span class="line">    pci_init(pacc);</span><br><span class="line">    pci_scan_bus(pacc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (dev = pacc-&gt;devices; dev; dev = dev-&gt;next) &#123;</span><br><span class="line">        pci_fill_info(dev, PCI_FILL_IDENT);</span><br><span class="line">        pci_lookup_name(pacc, namebuf, <span class="keyword">sizeof</span>(namebuf), PCI_LOOKUP_DEVICE, dev-&gt;vendor_id, dev-&gt;device_id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04x:%02x:%02x.%d %s\n&quot;</span>, dev-&gt;domain, dev-&gt;bus, dev-&gt;dev, dev-&gt;func, namebuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pci_cleanup(pacc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Installing-and-Running-lspci"><a href="#Installing-and-Running-lspci" class="headerlink" title="Installing and Running lspci"></a><strong>Installing and Running <code>lspci</code></strong></h3><ol>
<li>Install <code>lspci</code>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install pciutils</span><br></pre></td></tr></table></figure></li>
<li>Run <code>lspci</code> to list PCI devices:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci</span><br></pre></td></tr></table></figure></li>
<li>Use <code>lspci -vvv</code> to display detailed information about each device.</li>
</ol>
<hr>
<h2 id="Practical-Examples"><a href="#Practical-Examples" class="headerlink" title="Practical Examples"></a><strong>Practical Examples</strong></h2><h3 id="USB-Device-Testing"><a href="#USB-Device-Testing" class="headerlink" title="USB Device Testing"></a><strong>USB Device Testing</strong></h3><ol>
<li>Connect a USB device.</li>
<li>Use <code>lsusb</code> to verify detection:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure></li>
<li>Check driver binding:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /sys/bus/usb/drivers/</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="I2C-Device-Testing"><a href="#I2C-Device-Testing" class="headerlink" title="I2C Device Testing"></a><strong>I2C Device Testing</strong></h3><ol>
<li>Load the <code>i2c-dev</code> kernel module:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> modprobe i2c-dev</span><br></pre></td></tr></table></figure></li>
<li>Use <code>lsi2c</code> to interact with an I2C device:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./lsi2c</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="PCI-Device-Testing"><a href="#PCI-Device-Testing" class="headerlink" title="PCI Device Testing"></a><strong>PCI Device Testing</strong></h3><ol>
<li>Run <code>lspci</code> to list devices:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci</span><br></pre></td></tr></table></figure></li>
<li>Check driver binding for a specific device:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -vvv -s &lt;bus:slot.func&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h2><p><code>sysfs</code> provides a rich interface for querying and manipulating kernel devices, while tools like <code>lsusb</code>, <code>lsi2c</code>, and <code>lspci</code> simplify testing and debugging of USB, I2C, and PCI devices. Understanding how these tools interact with the kernel and hardware equips developers to validate driver functionality and troubleshoot issues effectively.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://apexpeng.github.io/2024/12/31/linux-userspace-debug/" data-id="cm5c7gmuf000mdgvyggg5ch4r" data-title="Testing Linux I2C, USB, and PCI Drivers Using Userspace Tools and `Sysfs`" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux-v4l2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/31/linux-v4l2/" class="article-date">
  <time class="dt-published" datetime="2024-12-31T01:03:56.491Z" itemprop="datePublished">2024-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/31/linux-v4l2/">A Technical Overview of V4L2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>Video4Linux2 (V4L2)</strong> is a robust framework in the Linux kernel for handling video devices, including USB cameras. It provides a standardized API for video capture, making it the go-to interface for Linux-based video application development. This article delves into the memory management mechanisms V4L2 offers and demonstrates how to capture video from a USB camera with reference code.</p>
<hr>
<h2 id="1-Overview-of-V4L2-Memory-Management"><a href="#1-Overview-of-V4L2-Memory-Management" class="headerlink" title="1. Overview of V4L2 Memory Management"></a><strong>1. Overview of V4L2 Memory Management</strong></h2><p>V4L2 supports multiple memory management mechanisms for video buffers, providing flexibility for developers to choose based on their application’s needs. The framework uses buffers to exchange video frames between the driver and the application.</p>
<h3 id="Memory-Types-in-V4L2"><a href="#Memory-Types-in-V4L2" class="headerlink" title="Memory Types in V4L2"></a><strong>Memory Types in V4L2</strong></h3><ol>
<li><p><strong>MMAP (Memory Mapping):</strong></p>
<ul>
<li>Buffers are allocated in kernel space and memory-mapped to user space.</li>
<li>Suitable for most applications as it eliminates the need for copying data.</li>
</ul>
</li>
<li><p><strong>User Pointer (USERPTR):</strong></p>
<ul>
<li>The application allocates its own buffers in user space and provides pointers to the driver.</li>
<li>Provides greater control over memory management but requires more synchronization.</li>
</ul>
</li>
<li><p><strong>DMA Buffer (DMABUF):</strong></p>
<ul>
<li>Allows sharing buffers between devices using Direct Memory Access (DMA).</li>
<li>Common in zero-copy pipelines where efficiency is critical.</li>
</ul>
</li>
<li><p><strong>Read&#x2F;Write:</strong></p>
<ul>
<li>Simplest method where data is copied between the driver and user space.</li>
<li>Less efficient due to the overhead of copying but straightforward to implement.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-Steps-to-Capture-Video-from-a-USB-Camera-Using-V4L2"><a href="#2-Steps-to-Capture-Video-from-a-USB-Camera-Using-V4L2" class="headerlink" title="2. Steps to Capture Video from a USB Camera Using V4L2"></a><strong>2. Steps to Capture Video from a USB Camera Using V4L2</strong></h2><p>Below is a step-by-step guide to capturing video using V4L2, focusing on MMAP memory. </p>
<h3 id="Step-1-Open-the-Device"><a href="#Step-1-Open-the-Device" class="headerlink" title="Step 1: Open the Device"></a><strong>Step 1: Open the Device</strong></h3><p>Use the <code>open()</code> system call to access the video device (e.g., <code>/dev/video0</code>).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/dev/video0&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Opening video device&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Step-2-Query-Device-Capabilities"><a href="#Step-2-Query-Device-Capabilities" class="headerlink" title="Step 2: Query Device Capabilities"></a><strong>Step 2: Query Device Capabilities</strong></h3><p>Use the <code>VIDIOC_QUERYCAP</code> ioctl to ensure the device supports video capture.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/videodev2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_capability</span> <span class="title">cap</span>;</span></span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, VIDIOC_QUERYCAP, &amp;cap) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Querying capabilities&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Device does not support video capture\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Step-3-Set-the-Video-Format"><a href="#Step-3-Set-the-Video-Format" class="headerlink" title="Step 3: Set the Video Format"></a><strong>Step 3: Set the Video Format</strong></h3><p>Specify the desired frame size and pixel format using the <code>VIDIOC_S_FMT</code> ioctl.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> <span class="title">fmt</span>;</span></span><br><span class="line">fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">fmt.fmt.pix.width = <span class="number">640</span>;</span><br><span class="line">fmt.fmt.pix.height = <span class="number">480</span>;</span><br><span class="line">fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG; <span class="comment">// Or V4L2_PIX_FMT_YUYV</span></span><br><span class="line">fmt.fmt.pix.field = V4L2_FIELD_NONE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, VIDIOC_S_FMT, &amp;fmt) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Setting pixel format&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Step-4-Request-Buffers"><a href="#Step-4-Request-Buffers" class="headerlink" title="Step 4: Request Buffers"></a><strong>Step 4: Request Buffers</strong></h3><p>Allocate memory buffers in the kernel using the <code>VIDIOC_REQBUFS</code> ioctl.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> <span class="title">req</span>;</span></span><br><span class="line">req.count = <span class="number">4</span>; <span class="comment">// Number of buffers</span></span><br><span class="line">req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">req.memory = V4L2_MEMORY_MMAP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, VIDIOC_REQBUFS, &amp;req) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Requesting buffer&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Step-5-Map-Buffers-to-User-Space"><a href="#Step-5-Map-Buffers-to-User-Space" class="headerlink" title="Step 5: Map Buffers to User Space"></a><strong>Step 5: Map Buffers to User Space</strong></h3><p>Map the kernel buffers to user space using <code>mmap()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *start;</span><br><span class="line">    <span class="type">size_t</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">buffers</span> =</span> <span class="built_in">calloc</span>(req.count, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> buffer));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; req.count; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">    buf.index = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, VIDIOC_QUERYBUF, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Querying buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffers[i].length = buf.length;</span><br><span class="line">    buffers[i].start = mmap(<span class="literal">NULL</span>, buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, buf.m.offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffers[i].start == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Mapping buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Step-6-Queue-Buffers"><a href="#Step-6-Queue-Buffers" class="headerlink" title="Step 6: Queue Buffers"></a><strong>Step 6: Queue Buffers</strong></h3><p>Queue the buffers for the driver to fill with video frames.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; req.count; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">    buf.index = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, VIDIOC_QBUF, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Queueing buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Step-7-Start-Streaming"><a href="#Step-7-Start-Streaming" class="headerlink" title="Step 7: Start Streaming"></a><strong>Step 7: Start Streaming</strong></h3><p>Initiate the video capture process.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">v4l2_buf_type</span> <span class="title">type</span> =</span> V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, VIDIOC_STREAMON, &amp;type) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Starting stream&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Step-8-Capture-Video-Frames"><a href="#Step-8-Capture-Video-Frames" class="headerlink" title="Step 8: Capture Video Frames"></a><strong>Step 8: Capture Video Frames</strong></h3><p>Dequeue buffers, process the video data, and requeue them for continuous streaming.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; <span class="comment">// Capture 100 frames</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, VIDIOC_DQBUF, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Dequeueing buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process the video frame (e.g., save it to a file)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Captured frame %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, VIDIOC_QBUF, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Requeueing buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Step-9-Stop-Streaming-and-Clean-Up"><a href="#Step-9-Stop-Streaming-and-Clean-Up" class="headerlink" title="Step 9: Stop Streaming and Clean Up"></a><strong>Step 9: Stop Streaming and Clean Up</strong></h3><p>Terminate the video capture process and release resources.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ioctl(fd, VIDIOC_STREAMOFF, &amp;type) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Stopping stream&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; req.count; i++) &#123;</span><br><span class="line">    munmap(buffers[i].start, buffers[i].length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(buffers);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-Applications-of-V4L2"><a href="#3-Applications-of-V4L2" class="headerlink" title="3. Applications of V4L2"></a><strong>3. Applications of V4L2</strong></h2><p>V4L2 can be used in various applications, such as:</p>
<ul>
<li><strong>Video Streaming:</strong> Build real-time video streaming pipelines.</li>
<li><strong>Surveillance Systems:</strong> Capture and analyze video feeds from security cameras.</li>
<li><strong>Computer Vision:</strong> Process frames for object detection, tracking, and recognition.</li>
<li><strong>Media Recording:</strong> Record and save video content to disk.</li>
</ul>
<hr>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h2><p>V4L2 is a powerful and flexible interface for video device programming in Linux. By leveraging its memory management options and ioctl-based API, developers can efficiently capture and process video from USB cameras. The provided example demonstrates the key steps, from device initialization to capturing and processing frames, empowering developers to build robust video applications.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://apexpeng.github.io/2024/12/31/linux-v4l2/" data-id="cm5c7gmuf000ndgvyeskd49zj" data-title="A Technical Overview of V4L2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/10/CS_Basis_TEE/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/02/10/CS_Basis_HSM/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/02/10/CS_ASCP_01intro/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/12/31/wireless-modem-intro/">Comprehensive Technical Overview of Wireless Modems</a>
          </li>
        
          <li>
            <a href="/2024/12/31/wireless-modem-ucosii/">Implementing SMS-Triggered Functions With Wireless Modem in uC/OS-II</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Zhang Peng<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>