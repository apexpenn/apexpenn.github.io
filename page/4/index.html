<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>Page 4 | Penn&#39;s Blog</title>
  <meta name="author" content="apexpenn">
  
  <meta name="description" content="Our life is shaped by our mind; we become what we think.">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Penn&#39;s Blog"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Penn&#39;s Blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/archives">ARCHIVE</a></li>
    
      <li><a href="/about">ABOUT</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-CS_TEC_Linux_PAM" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-02-13T00:58:39.040Z"><a href="/2025/02/13/CS_TEC_Linux_PAM/">2025-02-13</a></time>
      
      
  
    <h1 class="title"><a href="/2025/02/13/CS_TEC_Linux_PAM/">Understanding Linux PAM (Pluggable Authentication Modules)</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Linux PAM (Pluggable Authentication Modules) represents a powerful framework that provides dynamic authentication support for applications and services in Linux systems. This article explores the fundamentals of PAM, its architecture, configuration syntax, and practical implementation examples.</p>
<h2 id="Core-Concepts"><a href="#Core-Concepts" class="headerlink" title="Core Concepts"></a>Core Concepts</h2><p>PAM operates as a middle layer between applications and authentication mechanisms. When an application needs to authenticate a user, it doesn’t need to know the details of how authentication works - it simply makes calls to the PAM framework, which handles the actual authentication process based on the system’s configuration.</p>
<h3 id="Key-Benefits"><a href="#Key-Benefits" class="headerlink" title="Key Benefits"></a>Key Benefits</h3><p>The modular nature of PAM provides several advantages:</p>
<ol>
<li>Applications don’t need to be modified to support new authentication mechanisms</li>
<li>System administrators can modify authentication requirements without changing application code</li>
<li>Multiple authentication methods can be combined flexibly</li>
<li>Authentication policies can be standardized across the system</li>
</ol>
<h2 id="PAM-Architecture"><a href="#PAM-Architecture" class="headerlink" title="PAM Architecture"></a>PAM Architecture</h2><h3 id="Service-Modules"><a href="#Service-Modules" class="headerlink" title="Service Modules"></a>Service Modules</h3><p>PAM divides authentication tasks into four independent management groups:</p>
<ol>
<li><strong>account</strong>: Verifies account accessibility, expiration, and access hours</li>
<li><strong>auth</strong>: Handles user authentication and sets credentials</li>
<li><strong>password</strong>: Manages password updates and validation</li>
<li><strong>session</strong>: Manages tasks needed to set up and tear down user sessions</li>
</ol>
<h3 id="Module-Types"><a href="#Module-Types" class="headerlink" title="Module Types"></a>Module Types</h3><p>Each management group can use various module types:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">required      - Must succeed for authentication to continue</span><br><span class="line">requisite     - Must succeed, but fails immediately if not met</span><br><span class="line">sufficient    - Success is sufficient to satisfy the module requirements</span><br><span class="line">optional      - Module success/failure doesn&#x27;t impact authentication</span><br><span class="line">include       - Include other configuration files</span><br><span class="line">substack      - Similar to include but treats the included stack as a subunit</span><br></pre></td></tr></table></figure>

<h2 id="Configuration-Syntax"><a href="#Configuration-Syntax" class="headerlink" title="Configuration Syntax"></a>Configuration Syntax</h2><p>PAM configuration files are typically stored in <code>/etc/pam.d/</code>. Each service has its own configuration file. The basic syntax is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type    control_flag    module_path    module_arguments</span><br></pre></td></tr></table></figure>

<p>Example from <code>/etc/pam.d/sshd</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#%PAM-1.0</span><br><span class="line">auth       required     pam_securetty.so</span><br><span class="line">auth       required     pam_unix.so nullok</span><br><span class="line">account    required     pam_nologin.so</span><br><span class="line">account    required     pam_unix.so</span><br><span class="line">password   required     pam_unix.so nullok obscure min=4 max=8</span><br><span class="line">session    required     pam_unix.so</span><br><span class="line">session    required     pam_limits.so</span><br></pre></td></tr></table></figure>

<h2 id="Common-PAM-Modules"><a href="#Common-PAM-Modules" class="headerlink" title="Common PAM Modules"></a>Common PAM Modules</h2><h3 id="pam-unix-so"><a href="#pam-unix-so" class="headerlink" title="pam_unix.so"></a>pam_unix.so</h3><p>The standard Unix authentication module supporting standard Unix password authentication:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth required pam_unix.so try_first_pass nullok</span><br></pre></td></tr></table></figure>

<p>Parameters:</p>
<ul>
<li><code>try_first_pass</code>: Try using previously entered password</li>
<li><code>nullok</code>: Allow empty passwords</li>
<li><code>remember=N</code>: Remember N previous passwords</li>
</ul>
<h3 id="pam-ldap-so"><a href="#pam-ldap-so" class="headerlink" title="pam_ldap.so"></a>pam_ldap.so</h3><p>Provides LDAP authentication support:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth sufficient pam_ldap.so use_first_pass</span><br></pre></td></tr></table></figure>

<h3 id="pam-time-so"><a href="#pam-time-so" class="headerlink" title="pam_time.so"></a>pam_time.so</h3><p>Controls access based on time:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">account required pam_time.so</span><br></pre></td></tr></table></figure>

<p>Configuration in <code>/etc/security/time.conf</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">services;ttys;users;times</span><br><span class="line">login;tty*;!root;Al0800-1800</span><br></pre></td></tr></table></figure>

<h2 id="Practical-Examples"><a href="#Practical-Examples" class="headerlink" title="Practical Examples"></a>Practical Examples</h2><h3 id="Example-1-Enforcing-Strong-Passwords"><a href="#Example-1-Enforcing-Strong-Passwords" class="headerlink" title="Example 1: Enforcing Strong Passwords"></a>Example 1: Enforcing Strong Passwords</h3><p>To enforce password complexity, modify <code>/etc/pam.d/system-auth</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password required pam_pwquality.so retry=3 minlen=12 dcredit=1 ucredit=1 ocredit=1 lcredit=1</span><br><span class="line">password required pam_unix.so use_authtok sha512 shadow</span><br></pre></td></tr></table></figure>

<p>This configuration:</p>
<ul>
<li>Requires minimum 12 characters</li>
<li>Requires at least one digit, uppercase, special character, and lowercase</li>
<li>Allows 3 retry attempts</li>
<li>Uses SHA-512 hashing</li>
</ul>
<h3 id="Example-2-Limiting-Login-Attempts"><a href="#Example-2-Limiting-Login-Attempts" class="headerlink" title="Example 2: Limiting Login Attempts"></a>Example 2: Limiting Login Attempts</h3><p>To implement login attempt limits, add to <code>/etc/pam.d/system-auth</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth required pam_tally2.so deny=3 unlock_time=300 onerr=fail</span><br></pre></td></tr></table></figure>

<p>This configuration:</p>
<ul>
<li>Denies access after 3 failed attempts</li>
<li>Unlocks the account after 300 seconds</li>
<li>Fails closed (denies access) on errors</li>
</ul>
<h2 id="Debugging-PAM"><a href="#Debugging-PAM" class="headerlink" title="Debugging PAM"></a>Debugging PAM</h2><h3 id="Debug-Mode"><a href="#Debug-Mode" class="headerlink" title="Debug Mode"></a>Debug Mode</h3><p>Add the debug option to the module:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth required pam_unix.so debug</span><br></pre></td></tr></table></figure>

<p>View debug output in system logs:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f /var/log/auth.log</span><br></pre></td></tr></table></figure>

<h3 id="Testing-Configurations"><a href="#Testing-Configurations" class="headerlink" title="Testing Configurations"></a>Testing Configurations</h3><p>Use the <code>pamtester</code> utility to test PAM configurations:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pamtester sshd username authenticate</span><br></pre></td></tr></table></figure>

<h2 id="Security-Considerations"><a href="#Security-Considerations" class="headerlink" title="Security Considerations"></a>Security Considerations</h2><ol>
<li><p><strong>Order Matters</strong>: PAM processes modules in the order listed. Ensure critical security modules are placed appropriately.</p>
</li>
<li><p><strong>Fail Secure</strong>: Use appropriate control flags to ensure authentication fails securely when modules fail.</p>
</li>
<li><p><strong>Module Parameters</strong>: Carefully consider module parameters - some can weaken security if misconfigured.</p>
</li>
<li><p><strong>File Permissions</strong>: PAM configuration files should be owned by root and not writable by others:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 644 /etc/pam.d/*</span><br><span class="line"><span class="built_in">chown</span> root:root /etc/pam.d/*</span><br></pre></td></tr></table></figure>

<h2 id="Best-Practices"><a href="#Best-Practices" class="headerlink" title="Best Practices"></a>Best Practices</h2><ol>
<li><p><strong>Documentation</strong>: Always document PAM changes in configuration files using comments.</p>
</li>
<li><p><strong>Backup</strong>: Create backups before modifying PAM configurations:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /etc/pam.d /etc/pam.d.backup</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>Testing</strong>: Test changes in a non-production environment first.</p>
</li>
<li><p><strong>Monitoring</strong>: Regularly monitor auth logs for unusual patterns or failures.</p>
</li>
</ol>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Linux PAM provides a flexible and powerful framework for managing authentication in Linux systems. Understanding its architecture, configuration syntax, and proper implementation is crucial for system administrators and security professionals. Through careful configuration and following best practices, PAM can significantly enhance system security while maintaining usability.</p>
<p>Remember that PAM configurations can lock users out of the system if implemented incorrectly. Always maintain a root session when testing new PAM configurations, and have a backup plan for recovery if authentication breaks.</p>
<p>For further information, consult the official Linux-PAM documentation and system-specific guides for your distribution.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-CS_Basis_TEE" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-02-13T00:58:39.019Z"><a href="/2025/02/13/CS_Basis_TEE/">2025-02-13</a></time>
      
      
  
    <h1 class="title"><a href="/2025/02/13/CS_Basis_TEE/">Comprehensive Guide to TEE</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Trusted Execution Environments (TEEs) are CPU-encrypted isolated private enclaves inside the memory, used for protecting data in use at the hardware level.</p>
<p>While the sensitive data is inside an enclave, unauthorized entities cannot remove it, modify it, or add more data to it. The contents of an enclave remain invisible and inaccessible to external parties, protected against outsider and insider threats.</p>
<p>As a result, a TEE ensures the following:</p>
<ul>
<li>Data integrity</li>
<li>Code integrity</li>
<li>Data confidentiality</li>
</ul>
<h1 id="TEE-terminology-and-operation"><a href="#TEE-terminology-and-operation" class="headerlink" title="TEE terminology and operation"></a>TEE terminology and operation</h1><p>In a system with a TEE, we have untrusted applications running on a Rich Execution Environment (REE) and trusted applications (TAs) running on a Trusted Execution Environment (TEE).</p>
<p>Only trusted applications running on a TEE (Secure World) have complete access to the main processor, peripherals and memory, while hardware isolation protects these from untrusted applications running on the main operating system (Non-Secure World).</p>
<h1 id="How-to-implement-a-TEE"><a href="#How-to-implement-a-TEE" class="headerlink" title="How to implement a TEE?"></a>How to implement a TEE?</h1><p>We could isolate applications in a “sandbox”, for example using containers. This would prevent an application from seeing and accessing data from other applications.</p>
<p>But what about the kernel? How to prevent a code running in kernel space from being exploited to access a certain peripheral or memory region used by a trusted application?</p>
<p>Software can’t protect software!</p>
<p>So we need support in the hardware to implement a TEE. We need a way to partition and isolate the hardware (busses, peripherals, memory regions, interrupts, etc) so that the running code does not have access to protected resources.</p>
<p>That’s where ARM’s TrustZone, RISC-V’s MultiZone and many other solutions come in.</p>
<p>Hardware support to implement a TEE:</p>
<ul>
<li>ARM’s TrustZone</li>
<li>RISC-V’s MultiZone</li>
<li>AMD Platform Security Processor (PSP)</li>
<li>Intel Software Guard Extensions (SGX)</li>
<li>Apple SEP (Secure Enclave Processor)</li>
<li>Google Titan M</li>
</ul>
<h2 id="ARM’s-TrustZone"><a href="#ARM’s-TrustZone" class="headerlink" title="ARM’s TrustZone"></a>ARM’s TrustZone</h2><p>Several commercial TEE implementations have been developed over the years:</p>
<ul>
<li>Trustonic Kinibi</li>
<li>Samsung TEEGRIS</li>
<li>Qualcomm  Qualcomm Secure Execution Environment (QSEE)</li>
<li>Google Trusty(opensource)</li>
<li>OP-TEE (<a target="_blank" rel="noopener" href="https://globalplatform.org/wp-content/uploads/2018/05/Introduction-to-Trusted-Execution-Environment-15May2018.pdf">Open Portable Trusted Execution Environment</a>) (opensource)</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-CS_Basis_HSM" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-02-13T00:58:38.976Z"><a href="/2025/02/13/CS_Basis_HSM/">2025-02-13</a></time>
      
      
  
    <h1 class="title"><a href="/2025/02/13/CS_Basis_HSM/">Comprehensive Guide to HSM</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>HSM, short for Hardware Security Module, is a physical device that acts as a fortress for your data, ensuring its confidentiality, integrity, and availability. HSMs are considered as standalone and tamper-resistant hardware devices specifically engineered to fortify cryptographic processes.</p>
<p>HSMs serve the essential functions of generating, safeguarding, and managing encryption keys, which are crucial for data encryption and decryption, and creating digital signatures and code signing certificates. HSMs can take the form of plugin cards or be integrated into various hardware components, including smart cards, appliances, and external devices.</p>
<p>These devices undergo rigorous testing, validation, and certification processes, adhering to strict security standards like FIPS 140-2, Common Criteria EAL 4+, or equivalent benchmarks. These benchmarks assure users that the devices offer unparalleled levels of security and shield against potential threats, ensuring the utmost confidentiality and integrity of data.</p>
<p>According to CerteraSSL’s <a target="_blank" rel="noopener" href="https://certera.com/blog/what-is-hardware-security-module-hsm-comprehensive-guide">HSM Comprehensive Guide</a>, let’s first walk through the Key components of HSM, different types of HSM, features of HSM and then look into some detail of Vehicular Hardware Security Module</p>
<h1 id="Key-components-of-HSM"><a href="#Key-components-of-HSM" class="headerlink" title="Key components of HSM"></a>Key components of HSM</h1><h2 id="Key-Generation-and-Storage"><a href="#Key-Generation-and-Storage" class="headerlink" title="Key Generation and Storage"></a>Key Generation and Storage</h2><p>HSMs use secure random number generators (RNGs) to generate strong cryptographic keys. The generated keys are securely stored within the HSM and safeguarded against unauthorized access or extraction, ensuring keys’ integrity and randomness, which are crucial for robust cryptographic operations.</p>
<h2 id="Key-Management"><a href="#Key-Management" class="headerlink" title="Key Management"></a>Key Management</h2><p>HSMs provide a comprehensive suite of key management functionalities, which includes key generation, import, export, versioning, and facilitating key lifecycle operations like rotation and retirement.</p>
<h2 id="Cryptographic-Operations"><a href="#Cryptographic-Operations" class="headerlink" title="Cryptographic Operations"></a>Cryptographic Operations</h2><p>HSM excels in performing various cryptographic operations. They offer encryption and decryption capabilities and play a critical role in generating and verifying digital signatures, ensuring the authenticity and integrity of electronic documents and transactions. They also support secure hashing algorithms for data integrity verification and provide secure APIs and interfaces for the seamless integration of cryptographic functionalities into applications.</p>
<h2 id="Secure-APIs-and-Interfaces"><a href="#Secure-APIs-and-Interfaces" class="headerlink" title="Secure APIs and Interfaces"></a>Secure APIs and Interfaces</h2><p>HSMs offer secure APIs and interfaces. APIs establish a secure communication channel between the application and the HSM, preventing unauthorized access and safeguarding cryptographic material from tampering.</p>
<h2 id="Physical-and-Logical-Security"><a href="#Physical-and-Logical-Security" class="headerlink" title="Physical and Logical Security"></a>Physical and Logical Security</h2><p>HSMs incorporate robust physical and logical security measures. Physical security features include tamper-evident casings, sensors to detect physical attacks and secure key storage mechanisms. Logical security encompasses robust authentication mechanisms, access controls, and cryptographic operations executed within a trusted environment.</p>
<h2 id="Compliance-and-Auditing"><a href="#Compliance-and-Auditing" class="headerlink" title="Compliance and Auditing"></a>Compliance and Auditing</h2><p>HSMs provide the necessary capabilities to comply with security regulations and industry standards. They offer auditing and logging mechanisms, enabling organizations to track and monitor cryptographic operations. Compliance features within HSMs assist in demonstrating adherence to security best practices and successfully passing regulatory audits.</p>
<h1 id="Types-of-HSM"><a href="#Types-of-HSM" class="headerlink" title="Types of HSM"></a>Types of HSM</h1><p>HSM devices come in various types, each tailored to specific use cases and industry requirements. However, there are two main types of HSMs:</p>
<h2 id="General-Purpose-HSMs"><a href="#General-Purpose-HSMs" class="headerlink" title="General Purpose HSMs:"></a>General Purpose HSMs:</h2><p>General purpose HSMs are versatile devices that support a wide range of encryption algorithms, such as CNG, CAPI, and more. They are designed to cater to various applications that require cryptographic services and secure key management.</p>
<p>General purpose HSMs are commonly used in environments where Public Key Infrastructures (PKIs) are implemented and in managing crypto-wallets and other sensitive data. These HSMs offer flexibility and compatibility with different systems and encryption standards.</p>
<h2 id="Payment-and-Transaction-HSMs"><a href="#Payment-and-Transaction-HSMs" class="headerlink" title="Payment and Transaction HSMs:"></a>Payment and Transaction HSMs:</h2><p>These HSM devices are tailored to the financial industry’s requirements and are essential in maintaining compliance with Payment Card Industry Data Security Standards (PCI DSS).</p>
<p>Payment and transaction HSMs provide specialized cryptographic services and secure key management solutions that align with the specific needs of payment processing systems. They play a critical role in securing financial transactions and ensuring the confidentiality and integrity of payment card data.</p>
<p>It’s important to note that while general purpose HSMs offer broader applicability, payment and transaction HSMs focus specifically on securing payment card information and complying with industry-specific standards. The choice between these two types of HSMs depends on the specific security requirements and use cases of the organization or industry involved.</p>
<h1 id="Features-of-HSM"><a href="#Features-of-HSM" class="headerlink" title="Features of HSM"></a>Features of HSM</h1><p>HSMs offer a range of features to provide maximum security for cryptographic key management and operations. Here are some key features:</p>
<h2 id="Tamper-Resistance"><a href="#Tamper-Resistance" class="headerlink" title="Tamper Resistance:"></a>Tamper Resistance:</h2><p>HSMs are built with tamper-evident casings and physical protections. They incorporate sensors and mechanisms that detect and respond to physical tampering attempts, such as opening the casing or tampering with internal components. These features ensure the integrity of the HSM and protect against unauthorized access to cryptographic keys.</p>
<h2 id="Zeroization-of-Keys"><a href="#Zeroization-of-Keys" class="headerlink" title="Zeroization of Keys:"></a>Zeroization of Keys:</h2><p>HSMs can securely erase cryptographic keys, ensuring their complete removal from the system and preventing unauthorized access or recovery.</p>
<h2 id="Access-Controls"><a href="#Access-Controls" class="headerlink" title="Access Controls:"></a>Access Controls:</h2><p>HSMs enforce strict access controls to prevent unauthorized users from accessing sensitive cryptographic material. Role-based access control (RBAC) mechanisms ensure that only authorized individuals or applications can interact with the HSM and perform cryptographic operations.</p>
<h2 id="Robust-Authentication"><a href="#Robust-Authentication" class="headerlink" title="Robust Authentication:"></a>Robust Authentication:</h2><p>HSMs employ strong authentication mechanisms to verify the identities of users or applications attempting to access the HSM. These devices mostly employ two-factor authentication, requiring a combination of something the user knows – a password and something the user has – a smart card or something the user is – biometric data to establish trust and grant access.</p>
<h2 id="APIs-and-Interfaces"><a href="#APIs-and-Interfaces" class="headerlink" title="APIs and Interfaces:"></a>APIs and Interfaces:</h2><p>HSMs provide secure APIs and interfaces that allow applications and systems to integrate with the HSM. Standard cryptographic protocol, are often supported, enabling seamless integration with existing systems.</p>
<h2 id="Secure-Design"><a href="#Secure-Design" class="headerlink" title="Secure Design:"></a>Secure Design:</h2><p>HSMs are designed with security in mind. They undergo rigorous testing and evaluation to meet recognized security standards, such as FIPS 140-2. The design principles encompass both physical and logical security measures to create a trusted environment for cryptographic operations.</p>
<h1 id="HSM-Specification"><a href="#HSM-Specification" class="headerlink" title="HSM Specification"></a>HSM Specification</h1><h2 id="Secure-Hardware-Extension-SHE"><a href="#Secure-Hardware-Extension-SHE" class="headerlink" title="Secure Hardware Extension (SHE)"></a>Secure Hardware Extension (SHE)</h2><p>The Secure Hardware Extension (SHE) is an on-chip extension to any given microcontroller. It is intended to move the control over cryptographic keys from the software domain into the hardware domain and therefore protect those keys from software attacks. However, it is not meant to replace highly secure solutions like TPM chips or smart cards, i.e. no tamper resistance is required by the specification.</p>
<p>In 2019, AUTOSAR continues publish new technical requirements instead of SHE v1.1 as <strong>AUTOSAR_TR_SecureHardwareExtensions.pdf</strong></p>
<p>SHE is one of the earliest examples of automotive-grade connected module hardening and quickly grew to become a standard requirement by OEMs on a global basis. It was primarily built for securing cryptographic key material against software attacks, but cannot really be used to protect communications (such as V2X). As such, it has served as a basis for later HSM standards (such as EVITA). Today, modern automotive HSMs leverage functionalities from SHE, TPM and smartcards.</p>
<h3 id="SHE-Background"><a href="#SHE-Background" class="headerlink" title="SHE Background"></a>SHE Background</h3><p>The HIS consortium was founded in 2004 and consists of members from Audi, BMW, Daimler, Porsche, and Volkswagen to address activities and develop common standards related to automotive manufacturing. In 2006, HIS published a document describing the requirements for an HIS Security Module standard that incorporated mechanisms for error detection, authorization, and authenticity. This was further developed by ESCRYPT in partnership with OEMs Audi and BMW, and semiconductor vendors, such as Freescale (now NXP) into an open standard, publicly released in April 2009.</p>
<p>The resulting SHE specification outlines how a secure zone can be created within any ECU via an on-chip extension within a Microcontroller Unit (MCU), providing cryptographic services at the application layer, and isolating the storage of secret keys from the remainder of the MCU’s resources. Although the standard originated within the German automotive industry at the OEM level, it has since become an open standard accepted at the global level.</p>
<h2 id="EVITA-HSM"><a href="#EVITA-HSM" class="headerlink" title="EVITA HSM"></a>EVITA HSM</h2><p>For vehicular hardware security module, we have to konw the E-safety vehicle intrusion protected applications (<a target="_blank" rel="noopener" href="https://evita-project.org/">EVITA</a>). EVITA is a project co-funded by the European Union within the Seventh Framework Programme for research and technological development.</p>
<p>The objective of EVITA is to design, verify, and prototype an architecture for automotive on-board networks where security-relevant components are protected against tampering and sensitive data are protected against compromise.</p>
<h3 id="EVITA’s-Background"><a href="#EVITA’s-Background" class="headerlink" title="EVITA’s Background"></a>EVITA’s Background</h3><p>Future automotive safety applications based on vehicle-to-vehicle and vehicle-to-infrastructure communication have been identified as a means for decreasing the number of fatal traffic accidents. Examples of such applications are local danger warnings and electronic emergency brakes. While these functionalities inspire a new era of traffic safety, new security requirements need to be considered in order to prevent attacks on these systems. Examples of such threats are forced malfunctioning of safety-critical components or the interference with the traffic flow by means of fake messages.</p>
<h3 id="EVITA’s-Objectives"><a href="#EVITA’s-Objectives" class="headerlink" title="EVITA’s Objectives"></a>EVITA’s Objectives</h3><p>Secure and trustworthy intra-vehicular communication is the basis for trustworthy communication among cars or between cars and the infrastructure. Therefore, the objective of the EVITA project is to design, verify, and prototype an architecture for automotive on-board networks where security-relevant components are protected against tampering and sensitive data are protected against compromise when transferred inside a vehicle.</p>
<p>By focusing on the protection of the intra-vehicle communication EVITA complements other e-safety related projects that focus on the protection of the vehicle-to-X communication.</p>
<h3 id="Design-Implementation-and-Evaluation-of-a-Vehicular-Hardware-Security-Module"><a href="#Design-Implementation-and-Evaluation-of-a-Vehicular-Hardware-Security-Module" class="headerlink" title="Design, Implementation, and Evaluation of a Vehicular Hardware Security Module"></a>Design, Implementation, and Evaluation of a Vehicular Hardware Security Module</h3><p>In 2011, the 14th International Conference on Information Security and Cryptology, M. Wolf, T. Gendrullis published a paper “<a target="_blank" rel="noopener" href="https://evita-project.org/Publications/WG11.pdf">Design, implementation, and evaluation of a vehicular hardware security module</a>“, introduce the vehicular HSM officially for the first time from EVITA point of view. Based on a requirements engineering approach that incorporates all security-relevant automotive use cases and all distinctive automotive needs and constraints, EVITA presented an vehicular hardware security module (HSM) that enables a holistic protection of in-vehicle ECUs and their communications. </p>
<h3 id="Standardize-Vehicular-HSM"><a href="#Standardize-Vehicular-HSM" class="headerlink" title="Standardize Vehicular HSM"></a>Standardize Vehicular HSM</h3><p>IT systems were never designed with security in mind. But with the increasing application of digital software and various radio interfaces to the outside world (including the Internet), modern vehicles are becoming even more vulnerable to all kinds of malicious encroachments like hackers or malware. This is especially noteworthy, since in contrast to most other IT systems, a successful malicious<br>encroachment on a vehicle will not only endanger critical services or business models, but can also endanger human lives. Thus strong security measures should be mandatory when developing vehicular IT systems. Today most vehicle manufacturer (hopefully) incorporate security as a design requirement.</p>
<p>However, realizing dependable IT security solutions in a vehicular environment considerably differs from realizing IT security for typical desktop or server environments, just porting “standard” security solutions to the, moreover, very heterogeneous IT environment usually will not work. In order<br>to reliably enforce the security of software security mechanisms, the application of hardware security modules (HSM) is one effective countermeasure as HSMs:</p>
<ul>
<li>protect software security measures by acting as trusted security anchor,</li>
<li>securely generate, store, and process security-critical material shielded from any potentially malicious software,</li>
<li>restrict the possibilities of hardware tampering attacks by applying effective tamper-protection measures, </li>
<li>accelerate security measures by applying specialized cryptographic hardware,</li>
<li>reduce security costs on high volumes by applying highly optimized special circuitry instead of costly general purpose hardware.</li>
</ul>
<p>Back to the paper was published, there already exist some proprietary and singlepurpose HSM realizations used, for instance, by vehicle immobilizers, digital tachographs or tolling solutions. However, these are no general-purpose, private HSMs and hence cannot be reused by other vehicular security solutions. On the other hand, general-purpose HSMs that are currently available, for instance, the IBM 4758 cryptographic co-processor, the TCG Mobile&#x2F;Trusted Platform Module, or typical cryptographic smartcards are not applicable for use within an automotive security context. They, for instance, lack of cost efficiency, performance, physical robustness, or security functionality. Solely, the secure hardware extension (SHE) as proposed by the HIS consortium takes an exceptional position as it was explicitly designed for application in a automotive security context. However, the SHE module is mainly built for securing cryptographic key material against software attacks, but cannot be used, for instance, to protect V2X communications. </p>
<p>Security requisites (SR) and functional requisites (FR) of EVITA HSM list as follows:</p>
<ul>
<li>SR.1 Autonomous, strongly isolated security processing environment</li>
<li>SR.2 Minimal immuftable trusted code to be executed prior to ECU processor</li>
<li>SR.3 Internal non-volatile memory for storing root security artifacts</li>
<li>SR.4 Non-detachable (tamper-protected) connection with ECU hardware</li>
<li>SR.5 Authentic, confidential, fresh comm. channel between HSM and ECU</li>
<li>SR.6 Autonomously controlled alert functionality (e.g., log entry, ECU halt)</li>
<li>SR.7 Only standardized, established security algorithms (e.g., NIST1 , BSI2)</li>
</ul>
</br>

<ul>
<li>FR.1 Physical stress resistance to endure an automotive life-cycle of ≥20 years</li>
<li>FR.2 Bandwidth and latency performance that meets at least ISO 11898 [24]</li>
<li>FR.3 Compatibility with existing ECU security modules, i.e. with HIS-SHE [21]</li>
<li>FR.4 Compatibility with existing ECU microprocessor architectures</li>
<li>FR.5 Open, patent free specifications for cost-efficient OEM-wide application</li>
</ul>
<h3 id="Comparison-of-HSMs"><a href="#Comparison-of-HSMs" class="headerlink" title="Comparison of HSMs"></a>Comparison of HSMs</h3><p>This can be seen in Table 5 of “<a target="_blank" rel="noopener" href="https://evita-project.org/Publications/WG11.pdf">Design, implementation, and evaluation of a vehicular hardware security module</a>“(Page 16).</p>
<h2 id="Trusted-Platform-Module"><a href="#Trusted-Platform-Module" class="headerlink" title="Trusted Platform Module"></a>Trusted Platform Module</h2><p>Due to the massive use of x86 chips in vehicle, Trusted Platform Module (TPM) was is and will be used in E&#x2F;E architecure to protect user data.</p>
<p>Back up to the days that hackers can quickly weaponize the valuable data in laptops and computers, <a target="_blank" rel="noopener" href="https://trustedcomputinggroup.org/">Trusted Computing Group (TCG)</a> develops and prompts specification and standards of TPM to against these threat. TPM is a secure crypto-processor which is attached to a device to establish secure operations. Using a TPM helps to protect a user’s identity and sensitive data by storing the relevant keys vital for encryption, decryption and authentication. Doing so provides a first line of defense against potentially critical malware and firmware attacks, as it ensures all data remains encrypted even if an attack takes place.</p>
<h1 id="Solutions-for-virtual-environments-of-TPM"><a href="#Solutions-for-virtual-environments-of-TPM" class="headerlink" title="Solutions for virtual environments of TPM"></a>Solutions for virtual environments of TPM</h1><h2 id="vTPM"><a href="#vTPM" class="headerlink" title="vTPM"></a>vTPM</h2><p>A vTPM is a software-based representation of a traditional TPM 2.0 chip. It carries out the same hardware-based security functions a TPM, for example, attestation, key and random number generation – without the physical chip being required.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-CS_Basis_IDS" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-02-10T02:41:56.730Z"><a href="/2025/02/10/CS_Basis_IDS/">2025-02-10</a></time>
      
      
  
    <h1 class="title"><a href="/2025/02/10/CS_Basis_IDS/">AutoSar IDS Architecture</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>Here,</p>
<ul>
<li><code>Doc Name</code> refer to docs that AutoSar published.</li>
<li><em>Section</em> as item to its parent.</li>
<li><strong>Definition</strong> The definition to important concept.</li>
</ul>
<h1 id="AutoSar-IDS-Reference-Documents"><a href="#AutoSar-IDS-Reference-Documents" class="headerlink" title="AutoSar IDS Reference Documents"></a>AutoSar IDS Reference Documents</h1><table>
<thead>
<tr>
<th>Domain</th>
<th>Documents</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>IdsM</td>
<td>AUTOSAR_RS_IntrusionDetectionSystem.pdf</td>
<td>This document specifies requirements for the AUTOSAR Intrusion Detection System (IDS) .</td>
</tr>
<tr>
<td>IDS Protocol Layer</td>
<td>AUTOSAR_PRS_IntrusionDetectionSystem.pdf</td>
<td>This Protocol Requirements Specification defines the format, message sequences and semantics of the AUTOSAR Protocol IDS</td>
</tr>
<tr>
<td>IdsM specification</td>
<td>AUTOSAR_SWS_IntrusionDetectionSystemManager.pdf</td>
<td>This specification describes the functionality, API, and the configuration for the AUTOSAR Basic Software module Intrusion Detection System Manager ( IdsM).</td>
</tr>
</tbody></table>
<h1 id="General-Architecture-of-a-distributed-onboard-IDS"><a href="#General-Architecture-of-a-distributed-onboard-IDS" class="headerlink" title="General Architecture of a distributed onboard IDS"></a>General Architecture of a distributed onboard IDS</h1><p>An onboard IDS according to the AUTOSAR standard consists of the following elements</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">graph BT;</span><br><span class="line">subgraph In-Vehicle</span><br><span class="line">subgraph ECUA</span><br><span class="line">A(Host Sensor)--&gt;C(IdsM)</span><br><span class="line">B(Ethernet Sensor)--&gt;C(IdsM)</span><br><span class="line">I(Sem)---C</span><br><span class="line">end</span><br><span class="line">subgraph ECUB</span><br><span class="line">E(Host Sensor)--&gt;G(IdsM)</span><br><span class="line">F(Ethernet Sensor)--&gt;G(IdsM)</span><br><span class="line">J(Sem)---G</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">C--&gt;D(IdsR)</span><br><span class="line">G--&gt;D</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph TSP</span><br><span class="line">H</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">D--&gt;H(SOC)</span><br><span class="line"></span><br><span class="line">style D stroke:#333,stroke-width:2px,stroke-dasharray: 5 5;</span><br></pre></td></tr></table></figure>

<p>As  listed, we got the following elements that constitute AutoSar IDS standard:</p>
<ul>
<li>Secure Sensor</li>
<li>Intrusion Detection System Manager(IDSM)</li>
<li>Security Event Memory(Sem)</li>
<li>Intrusion Detection System Repoter(IDSR)</li>
</ul>
<p>The Intrusion Detection System Manager (IdsM) is a Basic Software module (for the AUTOSAR Classic Platform) or a Platform Service (for the AUTOSAR Adaptive Platform) that collects and centrally aggregates security incidents that possibly result from malicious attacks on the vehicle’s software, communications or electronics system. In each of the security relevant ECUs or machines within the vehicle, an instance of the IdSM module or service collects and filters security events (optionally including additional data) in order to store them in a local Security Event Memory (Sem) and&#x2F;or to forward them over the vehicle network to a central Intrusion Detection System Reporter (IdsR). This IdsR might be, for example, located within a telematics unit enabling it to send security reports and associated data via a cellular network to an OEM’s Security Operations Center (SOC). This information is then analyzed by the Security Incident and Event Management (SIEM) and, if necessary, used to develop and decide on appropriate defense or mitigation actions to counter the attack.</p>
<h2 id="Security-Sensors-and-Security-Events"><a href="#Security-Sensors-and-Security-Events" class="headerlink" title="Security Sensors and Security Events"></a>Security Sensors and Security Events</h2><p>AUTOSAR BSW modules, CDD and SWC can act as Security Sensors. Security sensors report Security Events (SEv) to the IdsM, and the module IdsM itself can also be used as a Security Event sensor.</p>
<h2 id="IDSR"><a href="#IDSR" class="headerlink" title="IDSR"></a>IDSR</h2><p>IdsR is the bridge between Car and Backend, which is NOT SPECIFIED by AutoSar actually. The IdsR should typically further enrich the received data e.g. geo-position based on OEM requirement for the needs of SIEM.</p>
<h2 id="IDS-protocol"><a href="#IDS-protocol" class="headerlink" title="IDS protocol"></a>IDS protocol</h2><p>This Protocol Requirements Specification <code>AUTOSAR_PRS_IntrusionDetectionSystem</code> defines the format, message sequences and semantics of the AUTOSAR Protocol IDS.</p>
<p>The main use case for the IDS protocol is the propagation of Qualified Security Events QSEv to the IdsR in a way that is independent from the kind of ECU or the used communication mechanism.</p>
<h3 id="Protocol-specification"><a href="#Protocol-specification" class="headerlink" title="Protocol specification"></a>Protocol specification</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><table>
<thead>
<tr>
<th>Event Frame</th>
<th>Timestamp(optional)</th>
<th>Context Data(optional)</th>
<th>Signature(optional)</th>
</tr>
</thead>
</table>
<h4 id="Protocol-Detail"><a href="#Protocol-Detail" class="headerlink" title="Protocol Detail"></a>Protocol Detail</h4><table>
<thead>
<tr>
<th>FieldName</th>
<th>Length</th>
<th>Purpose</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Protocol Version</td>
<td>4 Bit</td>
<td>The version of the IdsM protocol</td>
<td></td>
</tr>
<tr>
<td>Protocol Header</td>
<td>4 Bit</td>
<td>IdsM protocol header information:</td>
<td>Bit 0: 0 - No Context Data included, 1 - Context Data included<br />Bit 1: 0 - No Timestamp included, 1 - Timestamp included<br />Bit 2: 0 - No Signature included, 1 - Signature included<br />Bit 3: reserved</td>
</tr>
<tr>
<td>IdsM Instance ID</td>
<td>10 Bit</td>
<td>Unique identifier of the sending, IdsM - Instance 0 - 1023</td>
<td></td>
</tr>
<tr>
<td>Sensor Instance ID</td>
<td>6 Bit</td>
<td>Identifier to differ between multiple instances of sensors</td>
<td></td>
</tr>
<tr>
<td>Event Definition ID</td>
<td>16 Bit</td>
<td>Unique identifier of a Security Event</td>
<td>Range of AUTOSAR internal IDs: 0…0x7FFF<br />Range of Customer specific IDs: 0x8000…0xFFFE</td>
</tr>
<tr>
<td>Count</td>
<td>16 Bit</td>
<td>Number of IdsM calls which result in the current event after processing the configured filter,</td>
<td>e.g. EventAggregation 1.. 65535 .</td>
</tr>
<tr>
<td>Reserved</td>
<td>8 Bit</td>
<td>Reserved for future use</td>
<td></td>
</tr>
<tr>
<td>Timestamp</td>
<td>64 Bit</td>
<td>Timestamp&#x2F;Timestamp when event was detected: (optional)</td>
<td>Byte0 - Bit7: 0 - AUTOSAR Standard, 1 - Auxiliary&#x2F; OEM specific<br />Byte0 - Bit 6: reserved<br />Resolution in ms. Maybe not necessary for every event type (optional).</td>
</tr>
<tr>
<td>Context Data</td>
<td>2..(2^31 + len) Bytes</td>
<td>Binary blob attached by the sensor. (optional)</td>
<td>Most Significant Bit of first byte signals if ContextData Length is encoded in<br />7 Bit (1 Byte) or 63 Bit (4 Bytes):<br />Context Data [0]: MSB &#x3D; 0 - 7 Bit Length Information encoded in Context Data [0]: 1..127<br />Context Data [0]: MSB &#x3D; 1 - 63 Bit Length Information encoded in Context Data [0..3]: 1..2^31<br />len &#x3D; 1 or 4</td>
</tr>
<tr>
<td>Signature</td>
<td>3…65537 Bytes</td>
<td>Signature for encryption of security event. (optional)</td>
<td>Signature calculated with Event Frame + optional Timestamp + optional Context Data<br />Signature[0..1]: Signature Length 1..65535</td>
</tr>
</tbody></table>
<p><strong>Byte Order</strong> The IDS protocol uses big endianess as byte order also known as Motorola format</p>
<h5 id="Event-Frame"><a href="#Event-Frame" class="headerlink" title="Event Frame"></a>Event Frame</h5><p>Event Frame consists of <strong>Protocol Version</strong>, <strong>Protocol Header</strong>, <strong>IdsM Instance ID</strong>, <strong>Sensor Instance ID</strong>, <strong>Event Definition ID</strong>, <strong>Count</strong> and <strong>Reserved</strong> part.</p>
<h5 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp"></a>Timestamp</h5><table>
<thead>
<tr>
<th>Source</th>
<th>Reserved</th>
<th>Nanoseconds</th>
<th>Seconds</th>
</tr>
</thead>
</table>
<p><strong>Bit 7: Souerce</strong></p>
<ul>
<li>0: AUTOSAR Standard CP: StbM - AP: ara::tsync</li>
<li>1: Auxiliary&#x2F; OEM Specific timestamp</li>
</ul>
<p>If Bit 7 &#x3D; 0, then:</p>
<ul>
<li>Reserve:Bit 6</li>
<li>Nanoseconds:Byte 0(0::5)::3</li>
<li>Seconds: Byte 4::7</li>
</ul>
<h5 id="Context-Data"><a href="#Context-Data" class="headerlink" title="Context Data"></a>Context Data</h5><p>The IDS protocol provides an optional feature to enrich the standard security event transfered in the Event Frame with more detailed information. Therefore context data can be added. It is a binary blob attached by the sensor. These data includes specific detailed information about the security event which can be used by the SOC for improved analysis of the security incident, e.g. a malformed message detected by a communication sensor.</p>
<p>IdsM has no knowledge of the content or structure of these data. Only the issuing sensor and the Backend or SOC knows it</p>
<h5 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h5><p>The IDS protocol provides an optional feature to make the transmission of QSEv more secure. A digital signature can be added to the IDS message. It can be used to ensure authenticity as well as to prove integrity of signed messages from the IdsM via all communication systems until reaching the Backend or SOC (End2End-Security).</p>
<h2 id="IDSM"><a href="#IDSM" class="headerlink" title="IDSM"></a>IDSM</h2><p>The Intrusion Detection System Manager handles security events reported by security sensors.</p>
<ul>
<li>IDSM privides a standardized interface for receiving SEvs. SEv can be reported with optional context data.</li>
<li>IDSM has the capability of qualifying SEvs, filters and transforms reported SEVs into QSEvs</li>
<li>QSEvs can be stroed locally on Security Event Memory(Sem) or forwarded towards configured sinks, or both.</li>
<li>Sinks could be Diagnostic Event Manager(Dem) and IDSR. Both may pass QSEv data to SOC.</li>
</ul>
<p>The IdsM shall provide interfaces for <strong>reporting SEv</strong>. The interfaces shall allow to report the following SEv properties:</p>
<ul>
<li>Security event type: Uniquely identifies the security event type</li>
<li>Context data: Optional data which can be used to analyze the security event in the SOC.</li>
<li>Timestamp: Optional timestamp provided by the sensor.</li>
<li>Count: Optional count provided by the sensor.</li>
</ul>
<p>IdsM shall provide mechanisms to add <strong>timestamps</strong> to SEvs.</p>
<p><strong>Timestamp Source</strong>s: IdsM shall provide mechanisms to let application or sensor software provide timestamps.</p>
<p>IdsM shall allow to transmit the QSEv and context data by <strong>using an IDS protocol</strong>, which is independent from the underlying bus technology</p>
<p>The IdsM shall be able to locally persist QSEvs via a user defined diagnostic memory. The user defined diagnostic memory shall be separate from the main diagnostic memory to allow separate access control and protection of the NVM block which is used to store the QSEv records. Persisted QSEvs can be accessed at a later point in time for analysis without relying on, e.g., network connectivity.</p>
<p>IdsM shall support limiting the rate of QSEvs transmitted to the IdsR and the bandwidth consumed by these transmissions.</p>
<h2 id="AUTOSAR-TPS-SecurityExtractTemplate"><a href="#AUTOSAR-TPS-SecurityExtractTemplate" class="headerlink" title="AUTOSAR_TPS_SecurityExtractTemplate"></a>AUTOSAR_TPS_SecurityExtractTemplate</h2><p>The Security Extract Template (SECXT) is part of the Intrusion Detection System (IDS).  In the context of ECU development projects, the SECXT serves multiple use cases. The SECXT specifies the security events and their properties for a vehicle on system level. The Security Extract as a specific, “standalone” file for security event definitions is in particular useful in view of the reasonable expectation that new approaches or kinds of attacks are identified after SOP of a vehicle. The resulting new or changed security events lead to an updated SECXT file that can subsequently be deployed onto the affected ECUs or machines of a vehicle together with a software update. Additionally, the SECXT file can potentially be used by the SIEM and SOC to interpret incoming reports of the IdsR instances of the vehicles in field.</p>
<p>To summarize, the Security Extract Template defines a standardized AUTOSAR exchange format for defining security events and their properties. The Security Extract (SECXT) is formalized as an ARXML file and applicable for both the AUTOSAR Adaptive and AUTOSAR Classic Platforms in a way similar to a Diagnostic Extract file.</p>
<h3 id="Conceptual-Background"><a href="#Conceptual-Background" class="headerlink" title="Conceptual Background"></a>Conceptual Background</h3><h4 id="Main-Development-Phases-for-an-IDS"><a href="#Main-Development-Phases-for-an-IDS" class="headerlink" title="Main Development Phases for an IDS"></a>Main Development Phases for an IDS</h4><p>Typically, an Intrusion Detection System (IDS) is based on the system parts IdsM, IdsR and the Security Operation Center (SOC) as exemplarily depicted in <a href="#general-architecture-of-a-distributed-onboard-ids">General Architecture of a distributed onboard IDS</a></p>
<p>The development of such an IDS can be divided into the following main phases:</p>
<ol>
<li>Security Analysis phase</li>
<li>IDS Design phase</li>
<li>IDS Deployment phase</li>
<li>IDS Operational phase</li>
</ol>
<p>The Security Extract Template supports all these four phases and can both be used for specification and exchange of IDS related definitions by and between OEMs and their suppliers. Therefore, a Security Extract file has potentially a high number of release cycles starting with security analysis and ending with “end of support” for a specific vehicle.</p>
<h5 id="Security-Analysis-Phase"><a href="#Security-Analysis-Phase" class="headerlink" title="Security Analysis Phase"></a>Security Analysis Phase</h5><p>In the Security Analysis phase, the vehicle’s electronics and software system is examined and analyzed by security experts to identify and evaluate potential approaches of attacks on the components of the system that could lead to a security breach. In a second step, based on these potential attack approaches, detectable events that deviate from the normal behavior of the system are identified and defined as Security Events.</p>
<h5 id="IDS-Design-Phase"><a href="#IDS-Design-Phase" class="headerlink" title="IDS Design Phase"></a>IDS Design Phase</h5><p>The IDS Design phase distributes, customizes and adapts the generic IDS components towards a concrete vehicle electronics and software system taking into consideration the security events identified in the previous phase</p>
<p>In this phase, the Security Extract Template is enriched with the design decisions such as definition of IdsM instances, the mapping of security events onto them and the configuration of filters</p>
<h5 id="IDS-Deployment-Phase"><a href="#IDS-Deployment-Phase" class="headerlink" title="IDS Deployment Phase"></a>IDS Deployment Phase</h5><p>The IDS Deployment phase comprises the realization of the IDS Design from the previous step towards the real system in hardware and software.</p>
<p>This phase is supported by the Security Extract Template through definition of IdsM instance deployment onto specific ECU-HW and the possibility to derive ECU configuration parameters for the IdsM modules on the Classic Platform</p>
<h5 id="IDS-Operational-Phase"><a href="#IDS-Operational-Phase" class="headerlink" title="IDS Operational Phase"></a>IDS Operational Phase</h5><p>The IDS Operational phase refers to the running IDS in the field when the vehicle is used by the end customer. </p>
<p>This phase is still regarded as part of the development process because it typically involves an IDS update process to keep the IDS up to date with new versions of application and platform software as well as with newly identified attack approaches and thus new security events.</p>
<p>During the IDS update process, Security Extract files can be used to reconfigure the IdsM instances of the IDS and also to make these reconfigurations known to the IdsR. </p>
<p>This is a notable difference to other AUTOSAR (M2 level) exchange files (e.g. System Description) which usually do not evolve further after the final configuration of the ECU-HW devices of the vehicle has been specified for SOP. On the other hand, the Security Extract file is expected to be maintained and further extended even after SOP of the vehicle it relates to due to its involvement in the IDS update process.</p>
<h1 id="Abbreviations"><a href="#Abbreviations" class="headerlink" title="Abbreviations"></a>Abbreviations</h1><table>
<thead>
<tr>
<th>Abbr</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>API</td>
<td>Application Programming Interface</td>
</tr>
<tr>
<td>BSW</td>
<td>Basic Software</td>
</tr>
<tr>
<td>BswM</td>
<td>Basic Software Mode Manager</td>
</tr>
<tr>
<td>CDD</td>
<td>Complex Device Driver</td>
</tr>
<tr>
<td>Csm</td>
<td>Crypto Service Manager</td>
</tr>
<tr>
<td>Dcm</td>
<td>Diagnostic Communication Manager</td>
</tr>
<tr>
<td>Dem</td>
<td>Diagnostic Event Manager module</td>
</tr>
<tr>
<td>DET</td>
<td>Default Error Tracer</td>
</tr>
<tr>
<td>ECU</td>
<td>Electronic Control Unit</td>
</tr>
<tr>
<td>ECUC</td>
<td>ECU configuration</td>
</tr>
<tr>
<td>ID</td>
<td>Identifier</td>
</tr>
<tr>
<td>IDS</td>
<td>Intrusion Detection System</td>
</tr>
<tr>
<td>IdsM</td>
<td>Intrusion Detection System Manager</td>
</tr>
<tr>
<td>IdsR</td>
<td>Intrusion Detection System Reporter</td>
</tr>
<tr>
<td>IF</td>
<td>Interface</td>
</tr>
<tr>
<td>MCU</td>
<td>Microcontroller Unit</td>
</tr>
<tr>
<td>NvM</td>
<td>Non-volatile memory</td>
</tr>
<tr>
<td>NVRAM</td>
<td>Non-volatile random access memory</td>
</tr>
<tr>
<td>OEM</td>
<td>Original Equipment Manufacturer</td>
</tr>
<tr>
<td>PDU</td>
<td>Protocol Data Unit</td>
</tr>
<tr>
<td>PDU ID</td>
<td>PDU Identifier</td>
</tr>
<tr>
<td>PduR</td>
<td>PDU Router</td>
</tr>
<tr>
<td>QSEv</td>
<td>Qualified Security Event</td>
</tr>
<tr>
<td>RTE</td>
<td>Runtime Environment</td>
</tr>
<tr>
<td>SecXT</td>
<td>Security Extract</td>
</tr>
<tr>
<td>Sem</td>
<td>Security Event Memory</td>
</tr>
<tr>
<td>SEv</td>
<td>On-board Security Event</td>
</tr>
<tr>
<td>SIEM</td>
<td>Security Incident and Event Management</td>
</tr>
<tr>
<td>StbM</td>
<td>Synchronized Time-Base Manager</td>
</tr>
<tr>
<td>SW-C</td>
<td>Software Component</td>
</tr>
<tr>
<td>SOC</td>
<td>Security Operation Center</td>
</tr>
<tr>
<td>TP</td>
<td>Transport Protocol</td>
</tr>
<tr>
<td>BSW</td>
<td>Basic Software</td>
</tr>
<tr>
<td>CDD</td>
<td>Complex Device Driver</td>
</tr>
<tr>
<td>SWC</td>
<td>Software Component</td>
</tr>
<tr>
<td>SWS</td>
<td>Software Specification</td>
</tr>
<tr>
<td>SOC</td>
<td>Security Operation Center</td>
</tr>
</tbody></table>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-CS_Basis_Diagnostic" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-02-10T02:41:56.728Z"><a href="/2025/02/10/CS_Basis_Diagnostic/">2025-02-10</a></time>
      
      
  
    <h1 class="title"><a href="/2025/02/10/CS_Basis_Diagnostic/">Comprehensive Guide to Diagnostic</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Diagnostic related history and concept, from OBD, UDS to DoCAN, DoIP etc.</p>
<h2 id="OBD"><a href="#OBD" class="headerlink" title="OBD"></a>OBD</h2><p>OBD stands for On-Board Diagnostics and is a computer system inside of a vehicle that tracks and regulates a car’s performance. This on-board computer system collects information from the network of sensors inside the vehicle, which the system can then use to regulate car systems or alert the user to problems. A technician can then simply plug into the OBD system to collect vehicle data and diagnose the problem. OBD systems have been a great help in helping users better understand vehicle diagnostics.</p>
<p>Based on ISO15765-1:2011(DoCAN) and ISO 13400-1:2011(DoIP), enhanced and legislated WWH-OBD diagnostic specifications applicable to the OSI layers are divided into:</p>
<table>
<thead>
<tr>
<th align="center">ISO 7498-1&#x2F;ISO 10731<br /> OSI 7 layers</th>
<th align="center">Vehicle manufacturer<br /> enhanced diagnostics</th>
<th>Legislated OBD</th>
<th align="left">Legislated WWH-OBD</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Application Layer</td>
<td align="center">ISO 14229-1,<br /> ISO 14229-3</td>
<td>ISO 15031-5</td>
<td align="left">ISO 27145-3,<br /> ISO 14229-1</td>
</tr>
<tr>
<td align="center">Presentation (layer 6)</td>
<td align="center">Vehicle manufacturer specific</td>
<td>ISO 15031-2,<br />  ISO 15031-5, <br />ISO 15031-6, <br />SAE J1930-DA, <br />SAE J1979-DA, <br />SAE J2012-DA</td>
<td align="left">ISO 27145-2,<br />SAE 1930-DA, <br />SAE J1979-DA, <br />SAE J2012-DA, <br />SAE J1939:2011, Appendix C (SPN),  <br />SAE J1939-73:2010,  Appendix A (FMI)</td>
</tr>
<tr>
<td align="center">Session (layer 5)</td>
<td align="center">ISO 14229-2</td>
<td>ISO 14229-2</td>
<td align="left">ISO 14229-2</td>
</tr>
<tr>
<td align="center">Transport protocol (layer 4)</td>
<td align="center">ISO 15765-2,<br />ISO 13400-2</td>
<td>ISO 15765-2,<br />ISO 15765-4</td>
<td align="left">ISO 15765-4,<br />ISO 15765-2, <br />ISO 27145-4,<br />ISO 13400-2</td>
</tr>
<tr>
<td align="center">Network (layer 3)</td>
<td align="center">ISO 15765-2,<br />ISO 13400-2</td>
<td>ISO 15765-2,<br />ISO 15765-4</td>
<td align="left">ISO 15765-4,<br />ISO 15765-2,<br />ISO 27145-4,<br />ISO 13400-2</td>
</tr>
<tr>
<td align="center">Data link (layer 2)<br />Physical (layer 1)</td>
<td align="center">ISO 11898-1,<br />ISO 11898-2, <br />ISO 11898-3, <br />ISO 11898-5,<br />ISO 13400-3,<br />or user defined</td>
<td>ISO 11898-1,<br />ISO 11898-2,<br />ISO 15765-4</td>
<td align="left">ISO 15765-4,<br />ISO 11898-1, <br />ISO 11898-2,<br />ISO 27145-4,<br />ISO 13400-3</td>
</tr>
</tbody></table>
<h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p>A basic OBD system consists of a central system, a network of sensors, a connection point and indicators, creating a complete monitoring system with standardized access and readability. The OBD system consists of the following components:</p>
<ul>
<li><strong>ECU:</strong> The central part of the OBD system is the Electronic Control Unit, or ECU. The ECU collects input from various sensors throughout the vehicle. The ECU then uses this data to either control parts of the vehicle, like fuel injectors, or monitor for issues.</li>
<li><strong>Sensors:</strong> There are sensors throughout vehicles covering every area from the engine and chassis to the electronic system itself. Each one of these systems sends codes to the ECU, specifying the source and the parameters of the signal. The ECU then “reads” and interprets this signal.</li>
<li><strong>DTC:</strong> If a sensor sends information to the ECU that falls outside of the normal range, the ECU saves the information as a code called a Diagnostic Trouble Code, or DTC. The DTC code essentially is a list of letters and numbers, which indicate the source and nature of the problem. DTC codes are usually standardized but may be manufacturer-specific. When a DTC is saved, the ECU sends a signal to your indicator light to state that a problem has been found. The DTC can also be pulled by linking a sensor to the connector for the OBD system.</li>
<li><strong>MIL:</strong> When the ECU collects a DTC code, it sends a signal to the vehicle dashboard to turn on the appropriate indicator lights. These lights, known formally as Malfunction Indicator Lights or MILs, provide an early warning system for vehicle malfunctions. Generally speaking, if the light turns on and stays on, the problem is minor. If the light flashes, the problem is urgent.</li>
<li><strong>DLC:</strong> All of the data and DTC codes collected by the ECU can be accessed via the Diagnostic Link Connector or DLC. The DLC port is the point of access for vehicles with OBD systems and is often found beneath the dashboard on the driver’s side of the vehicle, though it may be located elsewhere in commercial vehicles. Current vehicles are made with a standard OBDII system so that any scan tool with a type 2 cable can connect to the type 2 connector.</li>
</ul>
<h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p>The history of on-board diagnostics goes back to the 1960s. Several organizations set the groundwork for the standard, including the California Air Resources Board (CARB), the Society of Automotive Engineers (SAE), the International Organization for Standardization (ISO) and the Environmental Protection Agency (EPA).</p>
<p>It’s important to note that before standardization, manufacturers were creating their own systems. The tools from each manufacturer (and sometimes models from the same manufacturer) had their own connector type, electronic interface requirements. They also used their own custom codes for reporting problems.</p>
<p><strong>1968</strong> — The first OBD computer system with scanning capability was introduced by Volkswagen.</p>
<p><strong>1975</strong> — Datsun introduced a simple OBD system with limited non-standardized capabilities.</p>
<p><strong>1979</strong> — The Society of Automotive Engineers (SAE) recommends a standardized diagnostic connector and set of diagnostic test signals.</p>
<p><strong>1980</strong> — GM introduced a proprietary interface and protocol capable of providing engine diagnostics through an RS-232 interface or more simply, by flashing the Check Engine Light.</p>
<p><strong>1988</strong> — Standardization of on-board diagnostics came in the late 1980s after the 1988 SAE recommendation that called for a standard connector and set of diagnostics.</p>
<p><strong>1991</strong> — The state of California required all vehicles to have some form of basic on-board diagnostics. This is referred to as <strong>OBD I</strong>.</p>
<p><strong>1994</strong> — The state of California mandated that all vehicles sold in the state starting in 1996 must have OBD as recommended by SAE — now referred to as <strong>OBDII</strong>. This stems from the desire to perform across the board emissions testing. OBDII included a series of standardized <strong>diagnostic trouble codes</strong> (DTCs).</p>
<p><strong>1996</strong> — OBD-II becomes mandatory for all cars manufactured in the United States.</p>
<p><strong>2001</strong> — EOBD (European version of OBD) becomes mandatory for all gasoline vehicles in the European Union (EU).</p>
<p><strong>2003</strong> — EOBD becomes mandatory for all diesel vehicles in the EU.</p>
<p><strong>2006</strong> — All vehicles manufactured in Australia and New Zealand were required to be OBD2 compatible.</p>
<p><strong>2008</strong> — Starting in 2008, all vehicles in the US are required to implement OBDII through a <strong>Controller Area Network</strong> as specified by ISO 15765-4.</p>
<p><strong>2012</strong> — ISO 27145 consists of the following parts, under the general title Road vehicles <em>—</em> Implementation of <strong>World-Wide Harmonized On-Board Diagnostics</strong> (WWH-OBD) communication requirements</p>
<p><strong>2013</strong> — The ISO 13400 series has been established in order to define common requirements for vehicle diagnostic systems implemented on an IP communication link</p>
<p><strong>2021</strong> — SAE J1979-2 (“<strong>OBDonUDS</strong>”) , describes the communication between the vehicle’s OBD systems and test equipment required by OBD regulations. The new standard will be introduced in the USA from 2023 and will be mandatory from 2027</p>
<h2 id="UDS-ISO-14229"><a href="#UDS-ISO-14229" class="headerlink" title="UDS (ISO 14229)"></a>UDS (ISO 14229)</h2><p>The Automotive UDS Protocol, also known as Unified Diagnostic Services, is a communication protocol used in the automotive industry for diagnostics, debugging, and vehicle communication. It provides a standardized way for electronic control units (ECUs) in vehicles to communicate with diagnostic tools and software applications. The protocol is based on the ISO 14229 standard and is widely used by automotive manufacturers and service technicians.</p>
<p>ISO 14229 has been established in order to define common requirements for diagnostic systems, whatever the serial data link is.</p>
<p>To achieve this, ISO 14229 is based on the Open Systems Interconnection (OSI) Basic Reference Model in accordance with ISO&#x2F;IEC 7498-1 and ISO&#x2F;IEC 10731, which structures communication systems into seven layers. When mapped on this model, the services used by a diagnostic tester (client) and an Electronic Control Unit (ECU, server) are broken into the following layers in accordance with below table:</p>
<ul>
<li><strong>—</strong> Application layer (layer 7), unified diagnostic services specified in this document, ISO 14229-3 UDSonCAN, ISO 14229-4 UDSonFR, ISO 14229-5 UDSonIP, ISO 14229-6 UDSonK-Line, ISO 14229-7 UDSonLIN, ISO 14229-8 UDSonCXPI, further standards and ISO 27145-3 VOBD.</li>
<li><strong>—</strong> Presentation layer (layer 6), vehicle manufacturer specific, ISO 27145-2 <strong>VOBD</strong>.</li>
<li><strong>—</strong> Session layer services (layer 5) specified in ISO 14229-2.</li>
<li><strong>—</strong> Transport layer services (layer 4), specified in ISO 15765-2 DoCAN, ISO 10681-2 Communication on FlexRay, ISO 13400-2 DoIP, ISO 17987-2 LIN, ISO 20794-3 CXPI, ISO 27145-4 VOBD.</li>
<li><strong>—</strong> Network layer services (layer 3), specified in ISO 15765-2 DoCAN, ISO 10681-2 Communication on FlexRay, ISO 13400-2 DoIP, ISO 17987-2 LIN, ISO 20794-3 CXPI, ISO 27145-4 VOBD.</li>
<li><strong>—</strong> Data link layer (layer 2), specified in ISO 11898-1, ISO 11898-2, ISO 17458-2, ISO 13400-3, IEEE 802.3, ISO 14230-2, ISO 17987-3 LIN, ISO 20794-4 CXPI, and further standards, ISO 27145-4 VOBD.</li>
<li><strong>—</strong> Physical layer (layer 1), specified in ISO 11898-1, ISO 11898-2, ISO 17458-4, ISO 13400-3, IEEE 802.3, ISO 14230-1, ISO 17987-4 LIN, ISO 20794-4 CXPI, and further standards, ISO 27145-4 VOBD.</li>
</ul>
<table>
<thead>
<tr>
<th align="center">ISO 7498-1&#x2F;ISO 10731<br /> OSI 7 layers</th>
<th align="center">Vehicle manufacturer<br /> enhanced diagnostics</th>
<th>VOBD</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Application Layer</td>
<td align="center">ISO 14229-1,<br />ISO 14229-3 UDSonCAN, <br />ISO 14229-4 UDSonFR,<br />ISO 14229-5 UDSonIP,<br /> ISO 14229-6 UDSonK-Line,<br /> ISO 14229-7 UDSonLIN, <br />ISO 14229-8 UDSonCXPI,<br /> further standards</td>
<td>ISO 27145-3</td>
</tr>
<tr>
<td align="center">Presentation (layer 6)</td>
<td align="center">Vehicle manufacturer specific</td>
<td>ISO 27145-2</td>
</tr>
<tr>
<td align="center">Session (layer 5)</td>
<td align="center">ISO 14229-2</td>
<td>ISO 14229-2</td>
</tr>
<tr>
<td align="center">Transport protocol (layer 4)</td>
<td align="center">ISO 15765-2,<br />ISO 13400-2</td>
<td>ISO 27145-4</td>
</tr>
<tr>
<td align="center">Network (layer 3)</td>
<td align="center">ISO 15765-2,<br />ISO 13400-2</td>
<td>ISO 27145-4</td>
</tr>
<tr>
<td align="center">Data link (layer 2)<br />Physical (layer 1)</td>
<td align="center">ISO 11898-1,<br />ISO 11898-2, <br />ISO 11898-3, <br />ISO 11898-5,<br />ISO 13400-3,<br />or user defined</td>
<td>ISO 27145-4</td>
</tr>
</tbody></table>
<h1 id="UDS-Protocol"><a href="#UDS-Protocol" class="headerlink" title="UDS Protocol"></a>UDS Protocol</h1><p>The UDS protocol is a diagnostic protocol used in Automotive Vehicles to find the cause of a problem for the health check. Basically, it is used in the automotive field for vehicle diagnostic, ECU new software flashing, etc. Nowadays the use of the protocol is increasing due to its flexibility. This protocol is defined in ISO-14229-1 standard and it is derived from the ISO 14230-3 (KWP-2000) and ISO 15765-3 (Diagnostic Communication over the CAN (DoCAN).</p>
<p>The UDS (Unified Diagnostic Services) protocol operates at the 5th (Session layer) and 7th (Application layer) of the OSI model.</p>
<h2 id="UDS-Protocol-Architecture"><a href="#UDS-Protocol-Architecture" class="headerlink" title="UDS Protocol Architecture"></a><strong>UDS Protocol Architecture</strong></h2><p>Those services allow a tester (client) to control diagnostic functions in an on-vehicle Electronic Control Unit (server) applied for example on the electronic fuel injection, automatic gearbox, anti-lock braking system, etc., connected on a serial data link embedded in a road vehicle.</p>
<p>The server, usually a function that is part of the ECU, uses the application layer services to send response data, provided by the requested diagnostic service back to the client. The client is usually referred to as an External Test Equipment when it is off-board but can in some systems, also be an on-board tester. The usage of the application layer services is independent of the client being an off-board or on-board tester. It is a possibility to have more than one client on the same vehicle system.</p>
<p>The most typical network configuration of the client-server communication for the vehicle diagnostics: the client as an Off-board tester. Communication is based on a request-response model. In the context of diagnostics, the following concepts are useful for a better understanding of the semantics handled on the UDS standard environment:</p>
<ol>
<li><strong>Diagnostic Trouble Codes (DTC</strong> ): The numerical common identifier fault condition identified by the on-board diagnostic system.</li>
<li><strong>Diagnostic Data:</strong> Data that is located in the memory of an electronic control unit that may be inspected and&#x2F;or possibly modified by the tester (diagnostic data includes analogue inputs and outputs, digital inputs and outputs, intermediate values and various status information). EXAMPLES: vehicle speed, throttle angle, mirror position, system status, etc.</li>
<li><strong>Diagnostic Session</strong>: The current model of the server, which affects the level of diagnostic functionality.</li>
<li><strong>Diagnostic Routine</strong>: The routine that is embedded in an electronic control unit and that may be started by a server upon a request from the client. NOTE: It could either run instead of the normal operating program or run concurrently to the normal operating program. In the first case, the normal operation of the ECU is not possible. In the second case, multiple diagnostic routines may be enabled that run while all other parts of the electronic control unit are functioning normally.</li>
<li><strong>Tester</strong>: The system that controls functions such as test, inspection, monitoring or diagnosis of an in-vehicle electronic control unit and which may be dedicated to a specific type of operator (e.g. a scan tool dedicated to garage mechanics or a test tool dedicated to the assembly plant agents).</li>
</ol>
<h2 id="UDS-Protocol-Frame-Format"><a href="#UDS-Protocol-Frame-Format" class="headerlink" title="UDS Protocol Frame Format"></a>UDS Protocol Frame Format</h2><p>UDS is a Request and Response-based protocol based on client-server architecture, and it has having unique service ID(SID). SID is the size of one byte, and it ranges from <strong><code>0x00</code></strong> to  <strong><code>0x3E</code></strong> .</p>
<p>Basically, there are 4 types of frame formats:</p>
<ol>
<li>Request frame with sub-function ID</li>
<li>Request frame without sub-function ID</li>
<li>Positive Response Frame</li>
<li>Negative Response Frame</li>
</ol>
<p>Use 0x11(ECU Reset) service as an example:</p>
<table>
<thead>
<tr>
<th>SID</th>
<th>Sub-function ID</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0x11</td>
<td>0x01</td>
<td>Hard Reset</td>
</tr>
<tr>
<td>0x11</td>
<td>0x02</td>
<td>Key-Off On Reset</td>
</tr>
<tr>
<td>0x11</td>
<td>0x03</td>
<td>Soft Reset</td>
</tr>
</tbody></table>
<h3 id="Request-Frame-Format"><a href="#Request-Frame-Format" class="headerlink" title="Request Frame Format"></a>Request Frame Format</h3><table>
<thead>
<tr>
<th><strong>Service ID (SID)</strong></th>
<th><strong>Sub-Function ID (optional)</strong></th>
<th><strong>Data Parameters</strong></th>
</tr>
</thead>
</table>
<h3 id="Response-Frame-Format"><a href="#Response-Frame-Format" class="headerlink" title="Response Frame Format"></a>Response Frame Format</h3><h4 id="Positive-Response"><a href="#Positive-Response" class="headerlink" title="Positive Response"></a><strong>Positive Response</strong></h4><p>In UDS diagnostics, the tester acts as a client, and ECUs act as a server. When the server (ECU)receives the service request from the tester, the server checks the message. If everything is fine, then it executes the requested service and responds to the client with a positive response. If the response is positive, then the 6th bit of the <strong>SID</strong> should be  <strong>1</strong> .</p>
<p>For example,</p>
<p>Service ID – 0x31 &#x3D;&gt;  0 0 1 1 0 0 0 1</p>
<p>For a positive response, 0 <strong>1</strong> 1 1 0 0 0 1 is equal to 0x71 (0x31 + 0x40).</p>
<p>In another way, we can say the positive response means  <strong>SID+ 0x40</strong> , There is no logical reason for this. Simply, it is defined in International standard IS0-14229-1:</p>
<table>
<thead>
<tr>
<th><strong>Service ID (SID) + 0x40</strong></th>
<th><strong>Sub-Function ID (optional)</strong></th>
<th><strong>Data Response Code</strong></th>
</tr>
</thead>
</table>
<h4 id="Negative-Response"><a href="#Negative-Response" class="headerlink" title="Negative Response"></a><strong>Negative Response</strong></h4><p>In UDS diagnostics, the tester acts as a client, and ECUs act as a server. When the server (ECU) receives the service request from the tester, ECU checks the message. If the server finds something wrong, then it executes the negative response and sends the Negative response code(NRC). There are some Negative Response Codes given below.</p>
<ol>
<li>General Rejection – <strong><code>0x10</code></strong></li>
<li>Sub-Function Not Supported – <strong><code>0x12</code></strong></li>
<li>Incorrect Message Length(IML) – <strong><code>0x13</code></strong></li>
<li>Busy Repeat Request – <strong><code>0x21</code></strong></li>
<li>Condition not correct – <strong><code>0x22</code></strong></li>
<li>Request sequence Error – <strong><code>0x24</code></strong></li>
<li>Request Out Of Range(ROOR) – <strong><code>0x31</code></strong></li>
<li>Security Access Denied – <strong><code>0x33</code></strong></li>
<li>Invalid Key – <strong><code>0x35</code></strong></li>
</ol>
<table>
<thead>
<tr>
<th><strong>0x7F</strong></th>
<th><strong>Service ID</strong></th>
<th><strong>Negative Response Code</strong></th>
</tr>
</thead>
</table>
<h2 id="Functions-of-Diagnostic-Services-In-UDS-Protocol"><a href="#Functions-of-Diagnostic-Services-In-UDS-Protocol" class="headerlink" title="Functions of Diagnostic Services In UDS Protocol"></a>Functions of Diagnostic Services In UDS Protocol</h2><p>Besides specifying services’ primitives and protocols that describe the client-server interaction, UDS also defines within its framework several functional units that comprise several services each, identified with a hexadecimal code. These units are intended for the different individual purposes that support the overall diagnostic function&#x2F;task. The UDS protocol having different services for the different types of work tasks to do on the server. These are having 6- types as:</p>
<ol>
<li>Diagnostic and communication management.</li>
<li>Data Transmission.</li>
<li>Stored Data Transmission.</li>
<li>Input&#x2F;Output Control.</li>
<li>Remote activation of routine.</li>
<li>Upload&#x2F;Download.</li>
</ol>
<p>Each functional group has more than one service ID for different-2 tasks so to get the detail of the above functional group and related services.</p>
<h3 id="Diagnostic-Session-Control"><a href="#Diagnostic-Session-Control" class="headerlink" title="Diagnostic Session Control"></a>Diagnostic Session Control</h3><p>The diagnostic session’s service ID is **0x10 **and the Response SID is  <strong>0x50</strong> . Diagnostic Session control is used for controlling the diagnostic session of the ECU. This service is used to change the current diagnostic session to a different session. These sessions are used to enable or disable a particular set of diagnostic functions and features in an ECU.</p>
<p>The main purpose of this diagnostic session is to give security to the ECU. It will prevent the ECU from unwanted access. And only an authorized person can access it. If every diagnostics service can access the ECU, it may get damaged by the wrong flashing of software.</p>
<p>So before making any diagnostic request, the Client must make sure that this service is accessible or not in the ECU current session. if not, then first send a request for session change after that desirable request shall be performed.</p>
<p>If the Server(ECU) is in a non-default session or if there is diagnostic inactivity for 5 seconds, the ECU goes back to the default session.</p>
<table>
<thead>
<tr>
<th><strong>Sub-function</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Default Session(0x01)</strong></td>
<td>* This session is in an idle state. Whenever the ECU is powered ON, it will be in this default session only. ECU remains in default session until another diagnostic session is requested from the client.<br />* Services like Write data byte identifier (0x2E), Read data byte identifier (0x22), ECU Reset (0x11), Tester Present (0x3E), and Reading DTC (0x19) are available in this session.<br />* Security access (0x27) is not available. This service has low security compared to all other diagnostics session control sub-functions.<br /><strong>Example</strong> : In a garage, a person is trying to read the Diagnostic Trouble Code(DTC).</td>
</tr>
<tr>
<td><strong>Programming Session(0x02)</strong></td>
<td>* This Session is used to program the ECU or transfer data from client to server.<br />* All the services that are allowed in the Default session are allowed in this session.<br />* ECUs are entered into default session if this session is ended or expired.<br /><strong>Example</strong> : Programming session is End line engineer flashing calibration software.</td>
</tr>
<tr>
<td><strong>Extended Session(0x03)</strong></td>
<td>* All services allowed in the Default session are allowed in this session<br />* This session is used to unlock the additional diagnostic functions also<br />* Security access(0x27) is allowed in this session, meaning security levels are unlocked in this session<br />* ECUs entered into default session if this session is ended or expired<br /><strong>Example</strong> : This session is End of line engineers doing a dynamic vehicle test to check the security level</td>
</tr>
<tr>
<td><strong>Safety system Diagnostic system(0x04)</strong></td>
<td>* Used to test all safety-critical diagnostic functions.<br />* This diagnostics session control sub-function has a high level of security.<br /><strong>Example</strong> : This session is checking the safety of Airbags, and tire pressure monitors.</td>
</tr>
<tr>
<td><strong>0x05 to 0x3F</strong></td>
<td>Reserved</td>
</tr>
<tr>
<td><strong>Vehicle Manufacture Specific (0x40 to 0x5F)</strong></td>
<td>This session depends on Each OEM, If they want to implement any session based on their requirement they can use it.</td>
</tr>
<tr>
<td><strong>System supplier Specific (0x60 to 0X7E)</strong></td>
<td>This session is also like Vehicle Manufacture Specific only but instead of the vehicle manufacturer, if the system suppliers want to implement any session based on their specific requirement they can use it.</td>
</tr>
<tr>
<td><strong>0x7F</strong></td>
<td>Reserved</td>
</tr>
</tbody></table>
<h3 id="ECU-Reset"><a href="#ECU-Reset" class="headerlink" title="ECU Reset"></a>ECU Reset</h3><p>The ECU reset’s service ID is <strong>0x11</strong> and the Response SID is  <strong>0x51</strong> .</p>
<table>
<thead>
<tr>
<th><strong>Sub-function</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Hard Reset (0x01)</strong></td>
<td>* Hard reset means removing the battery (power supply) from the ECU and connecting the ECU again with the battery.* In this type of reset, ECU re-initializes the core hardware components of the system and also It will re-initializes the Non-volatile and volatile memory.* This reset may lose some data because the battery is removed suddenly during the running time of the ECU.</td>
</tr>
<tr>
<td><strong>Key off On Reset (0x02))</strong></td>
<td>* The Key Off-On Reset is simply the ignition Off-On process of a vehicle. It is the normal sleep-wake-up mode of a Microcontroller.* When we are doing Key Off On reset ECUs will not get the power down immediately. It will go to the boot mode then it will store all the data in Non-Volatile memory and de-initialize the hardware variables without losing any data.* In this method of resetting, there is no chance of losing data. This is the proper way to reset, and most of the OEMs are using this type of ECU Reset.</td>
</tr>
<tr>
<td><strong>Soft Reset (0x03)</strong></td>
<td>* A soft reset is nothing but restarting the application’s main software. When we do this type of reset, the stack pointer of the microcontroller points to the**<code>main()</code>** function’s address. Then it will start to execute from first.For <strong>Example,</strong> will take a watchdog reset. Whenever hanging or any malfunctions are happening, this watchdog timer will reset the microcontroller and it will start from the <strong><code>main()</code></strong> function.</td>
</tr>
<tr>
<td><strong>Enable Rapid Power shutdown (0x04)</strong></td>
<td>* In this type of reset, ignition off will not occur. ECU will go to sleep mode and ECU is ready to wake up at any time.</td>
</tr>
<tr>
<td><strong>Disable Rapid Power shutdown (0x05)</strong></td>
<td>* This service is used to disable the previously enabled rapid power shutdown.</td>
</tr>
</tbody></table>
<h3 id="Security-Access"><a href="#Security-Access" class="headerlink" title="Security Access"></a>Security Access</h3><p>The Security Access’s service ID is **0x27 **and the Response SID is  <strong>0x67</strong>. This service will grant Read, and Write access to the particular service. Before processing any of the Service IDs(SID) operation, it’s mandatory to check the security access, to know whether, for this SID, the client has access to read or write.</p>
<p>Security access is granted based on these two:</p>
<ol>
<li>Seed (0x01)</li>
<li>Key (0x02)</li>
</ol>
<ul>
<li>The tester sends the request to unlock the ECU using SID <strong>0x27</strong> and sub-function ID  <strong>0x01</strong> . <strong>0x01</strong> means requesting for seed.</li>
<li>The UDS server receives the request assumes conditions are correct and generates the random seed and key based on a cryptographic algorithm and the Server sends the Seed to the client with a positive response.</li>
<li>With the received seed, the tester tool generates the key and sends this key to the server to unlock the ECU using SID <strong>0x27</strong> and sub-function ID  <strong>0x02</strong> . <strong>0x02</strong> means key.</li>
<li>If the unlock key sent by the tester tool(client) matches with the server expecting key it will send the positive response and Unlock the ECU otherwise it will send a negative response with the specific negative response code.</li>
</ul>
<h3 id="Authentication-Service"><a href="#Authentication-Service" class="headerlink" title="Authentication Service"></a>Authentication Service</h3><p>This Authentication service was added after the year 2020, and this is used to provide a standardized approach to more modern methods of authentication than are permitted by the Security Access ( <strong>0x27</strong> ) service, including bidirectional <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Authentication" title="Authentication">authentication</a> with PKI-based Certificate Exchange.</p>
<p>The Authentication’s service ID is <strong>0x29</strong> and the Response SID is  <strong>0x69</strong> .</p>
<h3 id="ReadMemoryByAddress-0x23-UDS-Protocol"><a href="#ReadMemoryByAddress-0x23-UDS-Protocol" class="headerlink" title="ReadMemoryByAddress (0x23): UDS Protocol"></a><strong>ReadMemoryByAddress (0x23):</strong> <strong>UDS Protocol</strong></h3><p>The ReadMemoryByAddress service enables the client to request memory data from the server. It involves specifying a starting address and the size of memory to be read.</p>
<p>The ReadMemoryByAddress request message is used to request memory data from the server based on the specified memory address and size. The byte count for the memory address and size is determined by the addressAndLengthFormatIdentifier (low and high nibble). Using a fixed addressAndLengthFormatIdentifier is also an option. Any unused bytes in the memory address or size parameter are padded with the value 00 hex in the higher range address locations.</p>
<h3 id="WriteMemoryByAddress-0x3D-UDS-Protocol"><a href="#WriteMemoryByAddress-0x3D-UDS-Protocol" class="headerlink" title="WriteMemoryByAddress (0x3D): UDS Protocol"></a><strong>WriteMemoryByAddress (0x3D):</strong> <strong>UDS Protocol</strong></h3><p>This service allows the client&#x2F;Tester to write information into the server&#x2F;ECU at one or more contiguous memory locations. The tester sends a memory address, and the number of bytes, and a data string (according to the number of bytes ). The ECU writes the data string into its memory. The addressAndLengthFormatIdentifier parameter in the request specifies The number of bytes used for the memory address and memory size parameter.</p>
<h3 id="Routine-Control-31-hex-UDS-Protocol"><a href="#Routine-Control-31-hex-UDS-Protocol" class="headerlink" title="Routine Control (31 hex): UDS Protocol"></a><strong>Routine Control (31 hex):</strong> <strong>UDS Protocol</strong></h3><p>The Vehicle Diagnostics may require testing the faulty component in a given range of parameters. During vehicle testing, certain system tests may need an extended runtime. To initiate a test, the client triggers a routine in the server’s memory. Two methods exist in this UDS Protocol remote request service: one where the client interrupts the routine to halt it, and the other where the server&#x2F;ECU completes the routine after a specified time frame. This service allows the client to initiate, interrupt, and check the result of a routine after successful execution.</p>
<p><strong>Requests:</strong> RoutineControlType:</p>
<ol>
<li>startRoutine (01 hex).</li>
<li>stopRoutine (02 hex).</li>
<li>reqestRoutineControl (03 hex).</li>
</ol>
<h3 id="Other-OBD-and-UDS-Ddiagnostic-Services"><a href="#Other-OBD-and-UDS-Ddiagnostic-Services" class="headerlink" title="Other OBD and UDS Ddiagnostic Services"></a>Other OBD and UDS Ddiagnostic Services</h3><p>One of the most important concepts in UDS is the diagnostic service identifier (SID), which is a one-byte code that specifies what kind of service the tester is requesting from the ECU.</p>
<table>
<thead>
<tr>
<th>SID</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>01-0Ahex</td>
<td>OBD services</td>
</tr>
<tr>
<td>10hex</td>
<td>DiagnosticSessionControl</td>
</tr>
<tr>
<td>11hex</td>
<td>ECUReset</td>
</tr>
<tr>
<td>14hex</td>
<td>ClearDiagnosticInformation</td>
</tr>
<tr>
<td>19hex</td>
<td>ReadDTCInformation</td>
</tr>
<tr>
<td>22hex</td>
<td>ReadDataByIdentifier</td>
</tr>
<tr>
<td>23hex</td>
<td>ReadMemoryByAddress</td>
</tr>
<tr>
<td>27hex</td>
<td>SecurtityAccess</td>
</tr>
<tr>
<td>29hex</td>
<td>Secure Diagnostics</td>
</tr>
<tr>
<td>2Ehex</td>
<td>WriteDataByIdentifier</td>
</tr>
<tr>
<td>2Fhex</td>
<td>InputOutputControlByIdentifier</td>
</tr>
<tr>
<td>31hex</td>
<td>RoutineControl</td>
</tr>
<tr>
<td>34hex</td>
<td>RequestDownload</td>
</tr>
<tr>
<td>35hex</td>
<td>RequestUpload</td>
</tr>
<tr>
<td>36hex</td>
<td>TransferData</td>
</tr>
<tr>
<td>37hex</td>
<td>RequestTransferExit</td>
</tr>
<tr>
<td>38hex</td>
<td>RequestFileTransfer</td>
</tr>
<tr>
<td>3Dhex</td>
<td>WriteMemoryByAddress</td>
</tr>
<tr>
<td>3Ehex</td>
<td>TesterPresent</td>
</tr>
<tr>
<td>85hex</td>
<td>ControlDTCSetting</td>
</tr>
<tr>
<td>86hex</td>
<td>ResponseOnEvent</td>
</tr>
<tr>
<td>87hex</td>
<td>LinkControl</td>
</tr>
</tbody></table>
<h1 id="ODX-Open-Diagnostic-data-eXchange"><a href="#ODX-Open-Diagnostic-data-eXchange" class="headerlink" title="ODX (Open Diagnostic data eXchange)"></a>ODX (Open Diagnostic data eXchange)</h1><p>The standard ODX ISO 22901-1 (O pen D iagnostic data e X change) describes an <strong>XML format</strong> for exchanging diagnostic data. It contains both diagnostic specifics and flash data for individual ECUs, as well as Information on accessing the entire vehicle network. The data is usually processed on a D-Server in accordance with ISO 22900-3.</p>
<p><strong>PDX</strong> （Packaged ODX）, a collection of CDX</p>
<h1 id="Timing-Performance"><a href="#Timing-Performance" class="headerlink" title="Timing Performance"></a>Timing Performance</h1><p>Timing parameters play a crucial role in Unified Diagnostic Services (UDS) for managing the timing aspects of diagnostic communication between electronic control units (ECUs) in vehicles and diagnostic tools. These parameters help regulate the timing of various diagnostic services and functions within the UDS protocol to ensure efficient and reliable communication. Some common timing parameters in UDS include:</p>
<ol>
<li><strong>P2 Timeout</strong> : This parameter defines the time interval between consecutive diagnostic requests from the diagnostic tool to the ECU. It ensures that the diagnostic tool does not overwhelm the ECU with requests.</li>
<li><em><em>P2</em> Timeout</em> *: This parameter is similar to P2 Timeout but is used for specific services that require a different timing interval.</li>
<li><strong>P3 Timeout</strong> : This parameter specifies the maximum time allowed for an ECU to respond to a diagnostic request. If the response is not received within this timeout period, the diagnostic tool may consider the request as failed.</li>
<li><strong>S3 Timeout</strong> : This parameter specifies the time interval for which an ECU should stay in the “response pending” state after receiving a request. If the ECU does not provide a response within this timeout, the diagnostic tool may consider the request as failed.</li>
<li><strong>Communication Timeout</strong> : This parameter sets the maximum time allowed for the completion of a diagnostic communication session between the diagnostic tool and the ECU.</li>
</ol>
<p>Proper configuration and management of timing parameters in UDS are essential for ensuring efficient and reliable diagnostic communication, minimizing delays, and preventing communication errors. Timing parameters help in optimizing the timing aspects of diagnostic services and ensuring timely exchange of diagnostic information between ECUs and diagnostic tools.</p>
<h1 id="Abbreviation"><a href="#Abbreviation" class="headerlink" title="Abbreviation"></a>Abbreviation</h1><table>
<thead>
<tr>
<th align="center">Abbreviation</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BRS</td>
<td align="left">bit rate switch</td>
</tr>
<tr>
<td align="center">BS</td>
<td align="left">BlockSize</td>
</tr>
<tr>
<td align="center">CAN</td>
<td align="left">controller area network</td>
</tr>
<tr>
<td align="center">CAN FD</td>
<td align="left">controller area network with flexible data rate and larger payload as defined in ISO 11898-1</td>
</tr>
<tr>
<td align="center">CLASSICAL CAN</td>
<td align="left">controller area network with static data rate and up to 8 data bytes as defined in ISO 11898-1</td>
</tr>
<tr>
<td align="center">CF</td>
<td align="left">ConsecutiveFrame</td>
</tr>
<tr>
<td align="center">CTS</td>
<td align="left">continue to send</td>
</tr>
<tr>
<td align="center">DA</td>
<td align="left">destination address</td>
</tr>
<tr>
<td align="center">DLC</td>
<td align="left">CAN frame data link layer data length code</td>
</tr>
<tr>
<td align="center">DoCAN</td>
<td align="left">diagnostic communication over controller area network</td>
</tr>
<tr>
<td align="center">ECM</td>
<td align="left">Engine Control Module</td>
</tr>
<tr>
<td align="center">ECU</td>
<td align="left">Electronic Control Unit</td>
</tr>
<tr>
<td align="center">FC</td>
<td align="left">FlowControl</td>
</tr>
<tr>
<td align="center">FF</td>
<td align="left">FirstFrame</td>
</tr>
<tr>
<td align="center">FF_DL</td>
<td align="left">FirstFrame data length in bytes</td>
</tr>
<tr>
<td align="center">FMI</td>
<td align="left">failure mode indicator</td>
</tr>
<tr>
<td align="center">FS</td>
<td align="left">FlowStatus</td>
</tr>
<tr>
<td align="center">ID</td>
<td align="left">identifier</td>
</tr>
<tr>
<td align="center">Mtype</td>
<td align="left">message type</td>
</tr>
<tr>
<td align="center">N&#x2F;A</td>
<td align="left">not applicable</td>
</tr>
<tr>
<td align="center">NA</td>
<td align="left">network address</td>
</tr>
<tr>
<td align="center">N_AE</td>
<td align="left">network address extension</td>
</tr>
<tr>
<td align="center">N_AI</td>
<td align="left">network address information</td>
</tr>
<tr>
<td align="center">N_Ar</td>
<td align="left">network layer timing parameter Ar</td>
</tr>
<tr>
<td align="center">N_As</td>
<td align="left">network layer timing parameter As</td>
</tr>
<tr>
<td align="center">N_Br</td>
<td align="left">network layer timing parameter Br</td>
</tr>
<tr>
<td align="center">N_Bs</td>
<td align="left">network layer timing parameter Bs</td>
</tr>
<tr>
<td align="center">N_ChangeParameter</td>
<td align="left">network layer service name</td>
</tr>
<tr>
<td align="center">N_Cr</td>
<td align="left">network layer timing parameter Cr</td>
</tr>
<tr>
<td align="center">N_Cs</td>
<td align="left">network layer timing parameter Cs</td>
</tr>
<tr>
<td align="center">N_Data</td>
<td align="left">network data</td>
</tr>
<tr>
<td align="center">N_PCI</td>
<td align="left">network protocol control information</td>
</tr>
<tr>
<td align="center">N_PCItype</td>
<td align="left">network protocol control information type</td>
</tr>
<tr>
<td align="center">N_PDU</td>
<td align="left">network protocol data unit</td>
</tr>
<tr>
<td align="center">N_SA</td>
<td align="left">network source address</td>
</tr>
<tr>
<td align="center">N_SDU</td>
<td align="left">network service data unit</td>
</tr>
<tr>
<td align="center">N_TA</td>
<td align="left">network target address</td>
</tr>
<tr>
<td align="center">SOM</td>
<td align="left">start of message</td>
</tr>
<tr>
<td align="center">SP</td>
<td align="left">nominal sample point</td>
</tr>
<tr>
<td align="center">SPN</td>
<td align="left">suspect parameter number</td>
</tr>
<tr>
<td align="center">STmin</td>
<td align="left">Separation Time minimum</td>
</tr>
<tr>
<td align="center">STRT</td>
<td align="left">serviceToRespondTo</td>
</tr>
<tr>
<td align="center">TA</td>
<td align="left">target address</td>
</tr>
<tr>
<td align="center">TCM</td>
<td align="left">transmission control module</td>
</tr>
<tr>
<td align="center">UDS</td>
<td align="left">unified diagnostic services</td>
</tr>
<tr>
<td align="center">USDT</td>
<td align="left">unacknowledged segmented data transfer</td>
</tr>
<tr>
<td align="center">UUDT</td>
<td align="left">unacknowledged unsegmented data transfer</td>
</tr>
<tr>
<td align="center">WWH-OBD</td>
<td align="left">world-wide harmonized on-board diagnostics</td>
</tr>
<tr>
<td align="center">ISO 15031</td>
<td align="left">OBD</td>
</tr>
<tr>
<td align="center">ISO 15765</td>
<td align="left">DoCAN</td>
</tr>
<tr>
<td align="center">ISO 13400</td>
<td align="left">DoIP</td>
</tr>
<tr>
<td align="center">ISO 14229</td>
<td align="left">UDS</td>
</tr>
<tr>
<td align="center">ISO 27145</td>
<td align="left">WWH-OBD</td>
</tr>
</tbody></table>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-FreeRTOS-STM32F429" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2024-12-31T01:03:56.476Z"><a href="/2024/12/31/FreeRTOS-STM32F429/">2024-12-31</a></time>
      
      
  
    <h1 class="title"><a href="/2024/12/31/FreeRTOS-STM32F429/">FreeRTOS: An Introduction and Porting Guide for STM32F429</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="Introduction-to-FreeRTOS"><a href="#Introduction-to-FreeRTOS" class="headerlink" title="Introduction to FreeRTOS"></a>Introduction to FreeRTOS</h2><p>FreeRTOS is a popular real-time operating system (RTOS) designed for embedded systems, providing a robust and lightweight solution for developing complex, time-critical applications. Developed by Real Time Engineers Ltd., FreeRTOS has become a go-to choice for microcontroller-based projects across various industries, including automotive, industrial automation, and consumer electronics.</p>
<h3 id="What-is-an-RTOS"><a href="#What-is-an-RTOS" class="headerlink" title="What is an RTOS?"></a>What is an RTOS?</h3><p>A Real-Time Operating System (RTOS) is specifically designed to handle time-sensitive tasks with predictable and deterministic timing. Unlike general-purpose operating systems, an RTOS ensures that critical tasks are completed within strict time constraints, making it essential for applications where timing is crucial.</p>
<h2 id="Core-Features-of-FreeRTOS"><a href="#Core-Features-of-FreeRTOS" class="headerlink" title="Core Features of FreeRTOS"></a>Core Features of FreeRTOS</h2><h3 id="1-Task-Management"><a href="#1-Task-Management" class="headerlink" title="1. Task Management"></a>1. Task Management</h3><p>FreeRTOS implements a priority-based preemptive scheduling mechanism. Key characteristics include:</p>
<ul>
<li>Flexible task creation and management</li>
<li>Support for multiple task priorities</li>
<li>Dynamic task creation and deletion</li>
<li>Lightweight task switching mechanism</li>
</ul>
<h3 id="2-Synchronization-Primitives"><a href="#2-Synchronization-Primitives" class="headerlink" title="2. Synchronization Primitives"></a>2. Synchronization Primitives</h3><p>The operating system provides robust synchronization mechanisms:</p>
<ul>
<li>Mutexes for resource protection</li>
<li>Semaphores for task synchronization</li>
<li>Queues for inter-task communication</li>
<li>Event groups for complex synchronization scenarios</li>
</ul>
<h3 id="3-Memory-Management"><a href="#3-Memory-Management" class="headerlink" title="3. Memory Management"></a>3. Memory Management</h3><p>FreeRTOS offers multiple memory allocation strategies:</p>
<ul>
<li>Static memory allocation</li>
<li>Dynamic memory allocation</li>
<li>Heap memory management with configurable allocation schemes</li>
</ul>
<h3 id="4-Low-Resource-Footprint"><a href="#4-Low-Resource-Footprint" class="headerlink" title="4. Low Resource Footprint"></a>4. Low Resource Footprint</h3><p>Designed for resource-constrained environments, FreeRTOS:</p>
<ul>
<li>Requires minimal RAM and ROM</li>
<li>Offers configurable kernel features</li>
<li>Supports a wide range of microcontrollers and architectures</li>
</ul>
<h2 id="Porting-FreeRTOS-to-STM32F429"><a href="#Porting-FreeRTOS-to-STM32F429" class="headerlink" title="Porting FreeRTOS to STM32F429"></a>Porting FreeRTOS to STM32F429</h2><h3 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h3><p>Before porting FreeRTOS to STM32F429, ensure you have:</p>
<ul>
<li>STM32F429 development board</li>
<li>MDK-ARM (Keil uVision) or equivalent development environment</li>
<li>FreeRTOS source code</li>
<li>STM32F429 hardware reference manual</li>
</ul>
<h3 id="Step-by-Step-Porting-Process"><a href="#Step-by-Step-Porting-Process" class="headerlink" title="Step-by-Step Porting Process"></a>Step-by-Step Porting Process</h3><h4 id="1-Project-Setup"><a href="#1-Project-Setup" class="headerlink" title="1. Project Setup"></a>1. Project Setup</h4><ol>
<li>Create a new MDK-ARM project for STM32F429</li>
<li>Include FreeRTOS source files in your project</li>
<li>Configure project include paths</li>
</ol>
<h4 id="2-Port-Specific-Configuration"><a href="#2-Port-Specific-Configuration" class="headerlink" title="2. Port-Specific Configuration"></a>2. Port-Specific Configuration</h4><p>Modify <code>FreeRTOSConfig.h</code> to customize the RTOS for STM32F429:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ    ( SystemCoreClock )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ    ( ( TickType_t ) 1000 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE ( ( size_t ) ( 64 * 1024 ) )</span></span><br></pre></td></tr></table></figure>

<h4 id="3-Implement-Processor-Specific-Ports"><a href="#3-Implement-Processor-Specific-Ports" class="headerlink" title="3. Implement Processor-Specific Ports"></a>3. Implement Processor-Specific Ports</h4><p>Create port files specific to ARM Cortex-M4:</p>
<ul>
<li><code>port.c</code>: Contains context switching and interrupt handling</li>
<li><code>portmacro.h</code>: Defines processor-specific macros</li>
</ul>
<h4 id="4-Interrupt-Management"><a href="#4-Interrupt-Management" class="headerlink" title="4. Interrupt Management"></a>4. Interrupt Management</h4><p>Configure system timer and PendSV interrupt for task switching:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> (INCLUDE_xTaskGetSchedulerState == 1)</span></span><br><span class="line">        <span class="keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            xPortSysTickHandler();</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> (INCLUDE_xTaskGetSchedulerState == 1)</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-Basic-Task-Creation-Example"><a href="#5-Basic-Task-Creation-Example" class="headerlink" title="5. Basic Task Creation Example"></a>5. Basic Task Creation Example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskMain</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// Task implementation</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Hardware initialization</span></span><br><span class="line">    </span><br><span class="line">    xTaskCreate(vTaskMain, </span><br><span class="line">                <span class="string">&quot;MainTask&quot;</span>, </span><br><span class="line">                configMINIMAL_STACK_SIZE, </span><br><span class="line">                <span class="literal">NULL</span>, </span><br><span class="line">                tskIDLE_PRIORITY, </span><br><span class="line">                <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Should never reach here</span></span><br><span class="line">    <span class="keyword">for</span> (;;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Common-Challenges-and-Solutions"><a href="#Common-Challenges-and-Solutions" class="headerlink" title="Common Challenges and Solutions"></a>Common Challenges and Solutions</h3><ol>
<li><strong>Interrupt Handling</strong>: Carefully manage interrupt priorities and nesting</li>
<li><strong>Memory Constraints</strong>: Optimize memory usage through static allocation</li>
<li><strong>Timing Precision</strong>: Calibrate system tick and task scheduling</li>
</ol>
<h2 id="Best-Practices"><a href="#Best-Practices" class="headerlink" title="Best Practices"></a>Best Practices</h2><ul>
<li>Use static allocation when possible</li>
<li>Implement proper task priority management</li>
<li>Utilize built-in synchronization primitives</li>
<li>Regularly profile and optimize task performance</li>
<li>Implement error handling and monitoring mechanisms</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>[O<br>Porting FreeRTOS to STM32F429 provides a powerful framework for developing real-time embedded applications. By understanding the core features and following a systematic porting approach, developers can leverage the full potential of both the microcontroller and the real-time operating system.</p>
<h2 id="Reference-Implementation-Details"><a href="#Reference-Implementation-Details" class="headerlink" title="Reference Implementation Details"></a>Reference Implementation Details</h2><h3 id="Key-Code-Snippets-from-apexpeng-FreeRTOS-STM32F429"><a href="#Key-Code-Snippets-from-apexpeng-FreeRTOS-STM32F429" class="headerlink" title="Key Code Snippets from apexpeng&#x2F;FreeRTOS_STM32F429"></a>Key Code Snippets from apexpeng&#x2F;FreeRTOS_STM32F429</h3><h4 id="1-System-Initialization-main-c"><a href="#1-System-Initialization-main-c" class="headerlink" title="1. System Initialization (main.c)"></a>1. System Initialization (main.c)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// System Clock Configuration</span></span><br><span class="line">    SystemInit();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// NVIC Priority Grouping Configuration</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LED Initialization</span></span><br><span class="line">    LED_Init();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// USART Initialization for Debugging</span></span><br><span class="line">    USART1_Init();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create Tasks</span></span><br><span class="line">    xTaskCreate(LED0_Task, <span class="string">&quot;LED0 Task&quot;</span>, <span class="number">50</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(LED1_Task, <span class="string">&quot;LED1 Task&quot;</span>, <span class="number">50</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Start FreeRTOS Scheduler</span></span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Should never reach here</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Task-Implementation-Example"><a href="#2-Task-Implementation-Example" class="headerlink" title="2. Task Implementation Example"></a>2. Task Implementation Example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LED0_Task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED0_Toggle();</span><br><span class="line">        vTaskDelay(<span class="number">500</span>);  <span class="comment">// Delay for 500 milliseconds</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED1_Toggle();</span><br><span class="line">        vTaskDelay(<span class="number">800</span>);  <span class="comment">// Delay for 800 milliseconds</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-FreeRTOS-Configuration-FreeRTOSConfig-h"><a href="#3-FreeRTOS-Configuration-FreeRTOSConfig-h" class="headerlink" title="3. FreeRTOS Configuration (FreeRTOSConfig.h)"></a>3. FreeRTOS Configuration (FreeRTOSConfig.h)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PREEMPTION              1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TICKLESS_IDLE           0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ                ( SystemCoreClock )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ                ( ( TickType_t ) 1000 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_PRIORITIES              ( 5 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMINIMAL_STACK_SIZE          ( ( uint16_t ) 128 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE             ( ( size_t ) ( 16 * 1024 ) )</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Interrupt-Handling-Example"><a href="#4-Interrupt-Handling-Example" class="headerlink" title="4. Interrupt Handling Example"></a>4. Interrupt Handling Example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint16_t</span> data = USART_ReceiveData(USART1);</span><br><span class="line">        <span class="comment">// Handle received data</span></span><br><span class="line">        USART_ClearITPendingBit(USART1, USART_IT_RXNE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Practical-Considerations"><a href="#Practical-Considerations" class="headerlink" title="Practical Considerations"></a>Practical Considerations</h3><p>The reference implementation demonstrates several critical aspects of FreeRTOS integration:</p>
<ul>
<li>Proper system initialization</li>
<li>Task creation with different priorities</li>
<li>Simple task implementations</li>
<li>Interrupt handling</li>
<li>Minimal configuration for STM32F429</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.freertos.org/documentation/">FreeRTOS Official Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://www.st.com/resource/en/reference_manual/rm0090-stm32f405-415-stm32f407-417-stm32f427-437-and-stm32f429-439-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf">STM32F429 Reference Manual</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apexpeng/FreeRTOS_STM32F429">GitHub Repository: apexpeng&#x2F;FreeRTOS_STM32F429</a></li>
</ul>
<p><strong>NOTE</strong>: The DAC function only works fine before tasks scheduler, the clock need to be set to fix this issue.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/3/" class="alignleft prev">Prev</a>
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="apexpeng.github.io">
  </form>
</div>


  

  

  
  <div class="widget widget-archives">
    <h3 class="title">Archives</h3>
    <div class="entry">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a><span class="archive-list-count">34</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2025 apexpenn
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
